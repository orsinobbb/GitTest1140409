<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>æ•™å­¸å‹è¥¿æ´‹æ£‹é–‹å±€è¨“ç·´ï¼ˆç´”å‰ç«¯ Demoï¼‰</title>

  <!-- chess.js: ç”¨æ–¼åˆæ³•èµ°æ³•/ç”¢ç”Ÿ SAN/å¥—ç”¨èµ°æ³• -->
  <script src="https://unpkg.com/chess.js@1.0.0-beta.8/dist/chess.umd.js"></script>

  <style>
    :root{
      --bg:#0b1220; --panel:#0f1a2f; --panel2:#111f3a;
      --text:#e7eefc; --muted:#9fb0d0; --line:rgba(255,255,255,.10);
      --accent:#63a4ff; --ok:#43d18a; --warn:#ffcc66; --danger:#ff6b6b;
      --shadow:0 18px 50px rgba(0,0,0,.35); --radius:16px; --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(135deg,#081022 0%, #0b1b3a 55%, #0a1222 100%);
      color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Noto Sans TC","Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      min-height:100vh;
    }
    header{
      padding:18px 18px 12px;
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; flex-wrap:wrap;
    }
    .brand{
      display:flex; flex-direction:column; gap:4px;
    }
    .brand h1{
      margin:0; font-size:18px; letter-spacing:.5px;
    }
    .brand .sub{
      color:var(--muted); font-size:13px;
    }
    .wrap{
      padding: 0 18px 22px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:16px;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
    }

    .card{
      background:rgba(15,26,47,.72);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;
      background:rgba(17,31,58,.6);
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .card .hd .title{
      font-weight:700;
      font-size:14px;
      letter-spacing:.3px;
    }
    .card .bd{ padding:14px; }

    .controls{
      display:grid; grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .controls .row{ display:flex; flex-direction:column; gap:6px; }
    label{ font-size:12px; color:var(--muted); }
    select, button{
      width:100%;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(11,18,32,.7);
      color:var(--text);
      padding:10px 12px;
      outline:none;
    }
    select:focus, button:focus{ border-color: rgba(99,164,255,.6); }
    button{
      cursor:pointer;
      transition: transform .03s ease, filter .15s ease, border-color .15s ease;
    }
    button:hover{ filter:brightness(1.06); border-color: rgba(99,164,255,.55); }
    button:active{ transform: translateY(1px); }
    .btns{
      display:grid; grid-template-columns: 1fr 1fr 1fr;
      gap:10px; margin-top:10px;
    }

    .layout{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }

    /* Board */
    .board-wrap{
      display:flex; flex-direction:column; gap:10px;
    }
    .board{
      width:360px; height:360px;
      border-radius:14px;
      overflow:hidden;
      border:1px solid var(--line);
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
      user-select:none;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      background: #14213d;
    }
    .sq{
      display:flex; align-items:center; justify-content:center;
      font-size:30px;
      position:relative;
      cursor:pointer;
    }
    .light{ background: rgba(236,236,236,.12); }
    .dark{ background: rgba(0,0,0,.22); }
    .sq:hover{ outline: 2px solid rgba(99,164,255,.35); outline-offset:-2px; }
    .sq.sel{ outline: 3px solid rgba(99,164,255,.85); outline-offset:-3px; }
    .sq.hint{ box-shadow: inset 0 0 0 3px rgba(67,209,138,.6); }
    .coords{
      display:flex; justify-content:space-between;
      color:var(--muted); font-size:12px;
      width:360px;
      padding: 0 2px;
    }
    .meta{
      display:flex; gap:10px; flex-wrap:wrap;
      font-size:12px; color:var(--muted);
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(11,18,32,.55);
      padding:6px 10px;
      border-radius:999px;
    }

    /* Right panel */
    .panel{
      display:flex; flex-direction:column; gap:12px;
    }
    .box{
      background:rgba(11,18,32,.55);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .box h3{
      margin:0 0 8px;
      font-size:13px;
      color: var(--text);
      letter-spacing:.2px;
    }
    .muted{ color:var(--muted); }
    .log{
      font-family: var(--mono);
      font-size:12px;
      line-height:1.5;
      white-space:pre-wrap;
      margin:0;
    }
    .status{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(11,18,32,.45);
      font-size:13px;
    }
    .status.ok{ border-color: rgba(67,209,138,.45); }
    .status.warn{ border-color: rgba(255,204,102,.55); }
    .status.danger{ border-color: rgba(255,107,107,.55); }
    .small{ font-size:12px; }

    /* Quiz */
    .choices{
      display:grid; gap:8px;
    }
    .choice{
      text-align:left;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(15,26,47,.45);
      padding:10px 12px;
    }

    .footer{
      padding: 0 18px 20px;
      color: var(--muted);
      font-size: 12px;
    }
    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
  </style>
</head>

<body>
<header>
  <div class="brand">
    <h1>æ•™å­¸å‹è¥¿æ´‹æ£‹é–‹å±€è¨“ç·´ï¼ˆç´”å‰ç«¯ Demoï¼‰</h1>
    <div class="sub">é–‹å±€æ¨¹ï¼ˆLineï¼‰Ã— æ•™å­¸è§£èªªï¼ˆExplanationï¼‰Ã— éŒ¯èª¤å›é¥‹ï¼ˆWrongMoveï¼‰Ã— ç·´ç¿’/æ¸¬é©—ï¼ˆExerciseï¼‰</div>
  </div>
  <div class="meta">
    <div class="pill">æ¨¡å¼ï¼šè³‡æ–™é©…å‹•æ•™å­¸</div>
    <div class="pill">å¼•æ“ï¼šchess.jsï¼ˆåˆæ³•èµ°æ³•/SANï¼‰</div>
    <div class="pill">å–®æª”å¯é›¢ç·šï¼ˆé¦–æ¬¡éœ€è¼‰å…¥ CDNï¼‰</div>
  </div>
</header>

<div class="wrap">
  <!-- Left: Controls -->
  <section class="card">
    <div class="hd">
      <div class="title">è¨­å®š</div>
      <div class="muted small">é¸é–‹å±€ â†’ é¸è·¯ç·š â†’ é¸æ¨¡å¼</div>
    </div>
    <div class="bd">
      <div class="controls">
        <div class="row">
          <label>é–‹å±€ï¼ˆOpeningï¼‰</label>
          <select id="selOpening"></select>
        </div>
        <div class="row">
          <label>è·¯ç·šï¼ˆLineï¼‰</label>
          <select id="selLine"></select>
        </div>
        <div class="row">
          <label>æ¨¡å¼ï¼ˆModeï¼‰</label>
          <select id="selMode">
            <option value="learn">ğŸ“– æ•™å­¸æ¨¡å¼ï¼ˆé€æ­¥è§£èªªï¼‰</option>
            <option value="practice">ğŸ¯ ç·´ç¿’æ¨¡å¼ï¼ˆä½ ä¸‹ + ç³»çµ±å›é¥‹ï¼‰</option>
            <option value="quiz">ğŸ§© æ¸¬é©—æ¨¡å¼ï¼ˆæ¦‚å¿µé¸æ“‡é¡Œï¼‰</option>
          </select>
        </div>
        <div class="row">
          <label>ä½ è¦æ‰®æ¼”ï¼ˆPractice Onlyï¼‰</label>
          <select id="selSide">
            <option value="w">ç™½æ–¹</option>
            <option value="b">é»‘æ–¹</option>
          </select>
        </div>
      </div>

      <div class="btns">
        <button id="btnReset">é‡ç½®</button>
        <button id="btnPrev">ä¸Šä¸€æ­¥</button>
        <button id="btnNext">ä¸‹ä¸€æ­¥</button>
      </div>

      <div style="margin-top:12px" class="status" id="statusBox">
        è«‹é¸æ“‡é–‹å±€èˆ‡è·¯ç·šï¼Œç„¶å¾Œé–‹å§‹ç·´ç¿’ã€‚
      </div>

      <div style="margin-top:12px" class="box">
        <h3>æœ¬ Demo çš„è³‡æ–™æ“´å……æ–¹å¼</h3>
        <div class="muted small">
          ä½ å¯ä»¥åœ¨ç¨‹å¼æœ€ä¸‹æ–¹çš„ <span style="font-family:var(--mono)">DATA</span> è£¡æ–°å¢ Opening / Line / Nodeï¼ˆå±€é¢ç¯€é»ï¼‰å³å¯ã€‚<br/>
          Node ç”¨ <span style="font-family:var(--mono)">fen</span> ç•¶å±€é¢éµï¼Œä¸¦æä¾›ï¼šæ¨è–¦è‘—æ³•ã€è§£èªªã€éŒ¯èª¤è‘—æ³•ã€æ¸¬é©—ã€‚
        </div>
      </div>
    </div>
  </section>

  <!-- Right: Board + Panels -->
  <section class="card">
    <div class="hd">
      <div class="title">æ£‹ç›¤èˆ‡æ•™å­¸</div>
      <div class="muted small" id="headlineRight">â€”</div>
    </div>
    <div class="bd">
      <div class="layout">
        <div class="board-wrap">
          <div class="board" id="board"></div>
          <div class="coords">
            <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
          </div>
          <div class="muted small" id="turnInfo">â€”</div>
        </div>

        <div class="panel">
          <div class="box">
            <h3>æ•™å­¸é‡é»ï¼ˆExplanationï¼‰</h3>
            <div id="explain" class="small muted">â€”</div>
          </div>

          <div class="box" id="quizBox" style="display:none;">
            <h3>å°æ¸¬é©—ï¼ˆExerciseï¼‰</h3>
            <div id="quizPrompt" class="small" style="margin-bottom:10px;">â€”</div>
            <div class="choices" id="quizChoices"></div>
            <div id="quizFeedback" class="small muted" style="margin-top:10px;">â€”</div>
          </div>

          <div class="box">
            <h3>æ£‹è­œï¼ˆSANï¼‰</h3>
            <pre class="log" id="pgnLog">â€”</pre>
          </div>

          <div class="box">
            <h3>ç³»çµ±è¨Šæ¯</h3>
            <pre class="log" id="sysLog">â€”</pre>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<div class="footer">
  æç¤ºï¼šæ­¤ Demo ä¸»è¦é©—è­‰ã€Œè³‡æ–™æ ¼å¼æ˜¯å¦è¶³ä»¥é©…å‹•æ•™å­¸äº’å‹•ã€ã€‚è‹¥ä½ è¦é€²ä¸€æ­¥åšåˆ°ã€Œæ›´å¤šåˆ†æ”¯ + è‡ªå‹•è©•ä¼° + é€²åº¦è¿½è¹¤ã€ï¼Œä¸‹ä¸€æ­¥å¯ä»¥åŠ ï¼šå­¸ç¿’è€… Profileã€éŒ¯èª¤çµ±è¨ˆã€æ¦‚å¿µåœ–è­œï¼ˆtagsï¼‰ã€ä»¥åŠ Stockfish è©•ä¼°ï¼ˆWASMï¼‰ã€‚
</div>

<script>
  // -----------------------------
  // Data (ä½ è¦æ“´å……é–‹å±€/åˆ†æ”¯å°±æ”¹é€™è£¡)
  // -----------------------------
  const DATA = {
    openings: [
      {
        opening_id: "OP001",
        name: "ç¾©å¤§åˆ©é–‹å±€ï¼ˆItalian Gameï¼‰",
        eco: "C50",
        difficulty: "Beginner",
        style: ["Open Game", "Tactical"],
        description: "å¿«é€Ÿç™¼å±•ã€é‡å° f7 å¼±é»çš„å…¸å‹å…¥é–€é–‹å±€ã€‚"
      }
    ],
    lines: [
      {
        line_id: "LINE_ITALIAN_MAIN",
        opening_id: "OP001",
        name: "ä¸»ç·šï¼š1.e4 e5 2.Nf3 Nc6 3.Bc4",
        line_type: "Main",
        // ä»¥ SAN å½¢å¼ä¿å­˜ï¼ˆæ•™å­¸èˆ‡æ¯”å°ç”¨ï¼‰
        move_sequence_san: ["e4", "e5", "Nf3", "Nc6", "Bc4"],
        teaching_focus: ["Development", "f7 Weakness", "Tempo"]
      }
    ],
    // Node ä»¥ã€Œåˆ°é”è©²å±€é¢æ™‚ã€è¦é¡¯ç¤ºçš„æ•™å­¸è³‡è¨Šç‚ºä¸»ï¼ˆè³‡æ–™é©…å‹•ï¼‰
    // key: fenï¼ˆå±€é¢ï¼‰
    nodes: [
      // startpos
      {
        fen: "startpos",
        title: "èµ·å§‹å±€é¢",
        is_key_teaching_point: true,
        explanation: "æˆ‘å€‘è¦ç”¨ç¾©å¤§åˆ©é–‹å±€ç¤ºç¯„ï¼šç”¨ã€ç™¼å±•ï¼‹ä¸­å¿ƒæ§åˆ¶ã€å»ºç«‹ä¸»å‹•æ¬Šã€‚",
        // åœ¨æ•™å­¸/ç·´ç¿’ä¸­ï¼Œç³»çµ±æœŸå¾…çš„ä¸‹ä¸€æ­¥ï¼ˆä¾†è‡ª line çš„ä¸‹ä¸€æ­¥ï¼‰
        // ä¹Ÿå¯ä»¥è¦†å¯«æˆå¤šå€‹å…è¨±èµ°æ³•ï¼ˆä¾‹å¦‚åŒä¸€å±€é¢æœ‰å¤šç¨®æ•™å­¸å¯è¡Œè·¯ï¼‰
        expected_next_san: ["e4"],
        wrong_moves: [
          {
            san: "a4",
            reason: "é‚Šå…µé€šå¸¸ä¸å½±éŸ¿ä¸­å¿ƒï¼Œå®¹æ˜“æµªè²»ç¯€å¥ã€‚",
            mistake_type: "No Center Impact"
          }
        ],
        exercise: {
          prompt: "é–‹å±€æœ€å„ªå…ˆçš„ç­–ç•¥é€šå¸¸æ˜¯ï¼Ÿ",
          choices: ["å…ˆåƒå­", "æ§åˆ¶ä¸­å¿ƒä¸¦ç™¼å±•å­åŠ›", "æŠŠåæ—©é»æ”¾å‡ºä¾†"],
          correct: "æ§åˆ¶ä¸­å¿ƒä¸¦ç™¼å±•å­åŠ›",
          feedback: "é–‹å±€é‡é»ï¼šä¸­å¿ƒæ§åˆ¶ã€å­åŠ›ç™¼å±•ã€ç‹å®‰å…¨ã€‚"
        }
      },

      // after 1.e4 (black to move)
      {
        fen: "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1",
        title: "1.e4 ä¹‹å¾Œï¼ˆé»‘æ–¹èµ°ï¼‰",
        is_key_teaching_point: true,
        explanation: "1.e4 ç›´æ¥æ¶ä¸­å¿ƒï¼ˆd5/f5ï¼‰ä¸¦æ‰“é–‹ä¸»æ•™èˆ‡çš‡åé€šé“ï¼Œæ˜¯æœ€å…¸å‹çš„é–‹æ”¾å‹é–‹å±€èµ·æ‰‹ã€‚",
        expected_next_san: ["e5"],
        wrong_moves: [
          {
            san: "a6",
            reason: "éæ–¼è¢«å‹•ï¼Œæ²’æœ‰å›æ‡‰ä¸­å¿ƒï¼Œå®¹æ˜“è®“ç™½æ–¹ç„¡å£“åŠ›å®Œæˆç™¼å±•ã€‚",
            mistake_type: "Passive"
          }
        ],
        exercise: null
      },

      // after 1...e5 (white to move)
      {
        fen: "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2",
        title: "1...e5 ä¹‹å¾Œï¼ˆç™½æ–¹èµ°ï¼‰",
        is_key_teaching_point: true,
        explanation: "é»‘æ–¹ç”¨ 1...e5 å°ç¨±å›æ‡‰ä¸­å¿ƒã€‚ç™½æ–¹å¸¸ç”¨ Nf3ï¼šä¸€é‚Šç™¼å±•ï¼Œä¸€é‚Šæ”»æ“Š e5ï¼Œé€™å«ã€å¸¶å¨è„…çš„ç™¼å±•ã€ã€‚",
        expected_next_san: ["Nf3"],
        wrong_moves: [
          {
            san: "Qh5",
            reason: "éæ—©å‡ºåé€šå¸¸æœƒè¢«å­åŠ›ï¼ˆå¦‚ Nc6ï¼‰è¿½è¶•ï¼Œæµªè²»ç¯€å¥ã€‚",
            mistake_type: "Early Queen Move"
          }
        ],
        exercise: {
          prompt: "ç‚ºä»€éº¼ 2.Nf3 å¸¸è¢«è¦–ç‚ºå¥½æ£‹ï¼Ÿ",
          choices: ["å› ç‚ºèƒ½ç›´æ¥å°‡æ­»", "å› ç‚ºåŒæ™‚ç™¼å±•ä¸¦æ”»æ“Š e5", "å› ç‚ºèƒ½ç«‹åˆ»æ›å"],
          correct: "å› ç‚ºåŒæ™‚ç™¼å±•ä¸¦æ”»æ“Š e5",
          feedback: "ä½ åœ¨é–‹å±€æƒ³è¦çš„æ˜¯ï¼šç™¼å±•ï¼ˆdevelopmentï¼‰ï¼‹ç¯€å¥ï¼ˆtempoï¼‰ã€‚"
        }
      },

      // after 2.Nf3 (black to move)
      {
        fen: "rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2",
        title: "2.Nf3 ä¹‹å¾Œï¼ˆé»‘æ–¹èµ°ï¼‰",
        is_key_teaching_point: false,
        explanation: "é»‘æ–¹é€šå¸¸ç”¨ Nc6 ä¿è­· e5 ä¸¦ç™¼å±•å­åŠ›ï¼Œç¶­æŒä¸­å¿ƒå¼µåŠ›ã€‚",
        expected_next_san: ["Nc6"],
        wrong_moves: [
          {
            san: "f6",
            reason: "é€™æœƒå‰Šå¼± e6ã€g6 ä¸¦è®“ç‹ç¿¼è®Šè„†ï¼ˆè€Œä¸”ä¹Ÿæ“‹åˆ°å­åŠ›ç™¼å±•ï¼‰ã€‚",
            mistake_type: "King Safety"
          }
        ],
        exercise: null
      },

      // after 2...Nc6 (white to move)
      {
        fen: "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3",
        title: "2...Nc6 ä¹‹å¾Œï¼ˆç™½æ–¹èµ°ï¼‰",
        is_key_teaching_point: true,
        explanation: "ç™½æ–¹çš„ Bc4 æ˜¯ç¾©å¤§åˆ©é–‹å±€çš„æ¨™èªŒï¼šä¸»æ•™å°æº– f7 â€”â€” é»‘æ–¹é–‹å±€å”¯ä¸€ã€åªè¢«åœ‹ç‹ä¿è­·ã€çš„å¼±é»æ ¼ã€‚",
        expected_next_san: ["Bc4"],
        wrong_moves: [
          {
            san: "Bb5",
            reason: "Bb5 æ˜¯è¥¿ç­ç‰™é–‹å±€ï¼ˆRuy Lopezï¼‰çš„è·¯ç·šï¼Œä¸æ˜¯ç¾©å¤§åˆ©ä¸»ç·šã€‚ä½ å¯ä»¥å¦å»ºä¸€æ¢ Line ä¾†æ•™å®ƒã€‚",
            mistake_type: "Different Opening Branch"
          }
        ],
        exercise: {
          prompt: "ç‚ºä½• f7 å¸¸è¢«ç¨±ç‚ºé»‘æ–¹é–‹å±€å¼±é»ï¼Ÿ",
          choices: ["å› ç‚ºé‚£è£¡æ”¾äº†çš‡å", "å› ç‚ºé€šå¸¸åªç”±åœ‹ç‹é˜²å®ˆ", "å› ç‚ºé‚£è£¡æ°¸é ä¸èƒ½èµ°å­"],
          correct: "å› ç‚ºé€šå¸¸åªç”±åœ‹ç‹é˜²å®ˆ",
          feedback: "é€™å°±æ˜¯ç¾©å¤§åˆ©é–‹å±€å¾ˆé©åˆæ•™ã€å¼±é»æ ¼ + å¿«é€Ÿç™¼å±•ã€çš„åŸå› ã€‚"
        }
      },

      // after 3.Bc4 (black to move) - we end demo line here
      {
        fen: "r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 2 3",
        title: "3.Bc4 ä¹‹å¾Œï¼ˆé»‘æ–¹èµ°ï¼‰",
        is_key_teaching_point: true,
        explanation: "åˆ°é€™è£¡ä½ å·²å®Œæˆï¼šä¸­å¿ƒå…µ + é¦¬ + è±¡ çš„æ¨™æº–ä¸‰æ­¥ç™¼å±•ã€‚æ¥ä¸‹ä¾†æœƒé€²å…¥æ›´å¤šåˆ†æ”¯ï¼ˆå¦‚ ...Bc5 / ...Nf6ï¼‰ã€‚",
        expected_next_san: ["Bc5", "Nf6"], // ç¤ºç¯„ï¼šåŒå±€é¢å¯å®¹è¨±å¤šå€‹æ•™å­¸åˆ†æ”¯
        wrong_moves: [
          {
            san: "Qh4",
            reason: "éæ—©å‡ºååŒæ¨£å®¹æ˜“è¢«è¿½è¶•ï¼Œä¸”å°é–‹å±€æ ¸å¿ƒï¼ˆç™¼å±•èˆ‡ç‹å®‰å…¨ï¼‰å¹«åŠ©æœ‰é™ã€‚",
            mistake_type: "Early Queen Move"
          }
        ],
        exercise: null
      }
    ]
  };

  // -----------------------------
  // App State
  // -----------------------------
  const { Chess } = window.Chess;
  let chess = new Chess(); // chess.js å…§éƒ¨ç‹€æ…‹
  let selectedSquare = null;

  // ç›®å‰é¸æ“‡
  let curOpeningId = null;
  let curLineId = null;
  let curMode = "learn";
  let curPracticeSide = "w";

  // line é€²åº¦ï¼ˆä»¥ ply / SAN åºåˆ—çš„ç´¢å¼•ä¾†æ§åˆ¶ï¼‰
  let lineSAN = [];
  let plyIndex = 0; // 0 è¡¨ç¤º startpos
  let historyFEN = []; // ä¾¿æ–¼å›é€€ï¼ˆæ¯å€‹ ply çš„ fenï¼‰

  // UI refs
  const elOpening = document.getElementById("selOpening");
  const elLine = document.getElementById("selLine");
  const elMode = document.getElementById("selMode");
  const elSide = document.getElementById("selSide");
  const elReset = document.getElementById("btnReset");
  const elPrev = document.getElementById("btnPrev");
  const elNext = document.getElementById("btnNext");

  const elBoard = document.getElementById("board");
  const elExplain = document.getElementById("explain");
  const elPgn = document.getElementById("pgnLog");
  const elSys = document.getElementById("sysLog");
  const elStatus = document.getElementById("statusBox");
  const elTurnInfo = document.getElementById("turnInfo");
  const elHeadlineRight = document.getElementById("headlineRight");

  const elQuizBox = document.getElementById("quizBox");
  const elQuizPrompt = document.getElementById("quizPrompt");
  const elQuizChoices = document.getElementById("quizChoices");
  const elQuizFeedback = document.getElementById("quizFeedback");

  // Piece map (unicode)
  const PIECE_UNI = {
    wp:"â™™", wn:"â™˜", wb:"â™—", wr:"â™–", wq:"â™•", wk:"â™”",
    bp:"â™Ÿ", bn:"â™", bb:"â™", br:"â™œ", bq:"â™›", bk:"â™š"
  };

  // -----------------------------
  // Helpers
  // -----------------------------
  function getLinesByOpening(openingId){
    return DATA.lines.filter(l => l.opening_id === openingId);
  }
  function getOpening(openingId){
    return DATA.openings.find(o => o.opening_id === openingId);
  }
  function getLine(lineId){
    return DATA.lines.find(l => l.line_id === lineId);
  }
  function getNodeByFEN(fen){
    // fen å¯èƒ½æ˜¯ "startpos"
    if (fen === "startpos") return DATA.nodes.find(n => n.fen === "startpos") || null;
    return DATA.nodes.find(n => n.fen === fen) || null;
  }
  function setStatus(kind, text){
    elStatus.className = "status" + (kind ? ` ${kind}` : "");
    elStatus.textContent = text;
  }
  function logSys(text){
    const prev = (elSys.textContent === "â€”") ? "" : elSys.textContent + "\n";
    elSys.textContent = (prev + text).trim();
  }
  function clearSys(){
    elSys.textContent = "â€”";
  }
  function updateHeadline(){
    const op = getOpening(curOpeningId);
    const li = getLine(curLineId);
    if(!op || !li){
      elHeadlineRight.textContent = "â€”";
      return;
    }
    elHeadlineRight.textContent = `${op.name} / ${li.name}`;
  }

  // -----------------------------
  // Board Rendering
  // -----------------------------
  function buildBoard(){
    elBoard.innerHTML = "";
    // ranks 8->1, files a->h
    const files = ["a","b","c","d","e","f","g","h"];
    for(let r=8; r>=1; r--){
      for(let f=0; f<8; f++){
        const sq = files[f] + r;
        const isLight = ( (f + r) % 2 === 1 ); // simple alternating
        const div = document.createElement("div");
        div.className = "sq " + (isLight ? "light" : "dark");
        div.dataset.sq = sq;
        div.addEventListener("click", onSquareClick);
        elBoard.appendChild(div);
      }
    }
  }

  function renderPosition(){
    // clear selections/hints
    [...elBoard.querySelectorAll(".sq")].forEach(s => {
      s.classList.remove("sel","hint");
      s.textContent = "";
    });

    const board = chess.board(); // 8x8 array, [rank][file] rank 0 is 8th
    const files = ["a","b","c","d","e","f","g","h"];
    for(let rankIdx=0; rankIdx<8; rankIdx++){
      for(let fileIdx=0; fileIdx<8; fileIdx++){
        const p = board[rankIdx][fileIdx];
        if(!p) continue;
        const sq = files[fileIdx] + (8 - rankIdx);
        const key = p.color + p.type; // e.g., 'wp'
        const el = elBoard.querySelector(`.sq[data-sq="${sq}"]`);
        if(el) el.textContent = PIECE_UNI[key] || "";
      }
    }

    // update info
    const turn = chess.turn() === "w" ? "ç™½æ–¹" : "é»‘æ–¹";
    elTurnInfo.textContent = `è¼ªåˆ°ï¼š${turn}ï½œFENï¼š${chess.fen()}`;
    elPgn.textContent = chess.pgn({ newline_char: "\n" }) || "â€”";

    // explanation driven by node
    const node = getNodeByFEN(getCurrentNodeFENKey());
    if(node?.explanation){
      elExplain.textContent = node.explanation;
    }else{
      elExplain.textContent = "ï¼ˆæ­¤å±€é¢å°šæœªé…ç½®æ•™å­¸è§£èªªï¼‰";
    }

    // quiz mode: show exercise (if exists)
    if(curMode === "quiz"){
      renderQuiz(node);
    }else{
      elQuizBox.style.display = "none";
    }
  }

  function highlightMoves(fromSq){
    [...elBoard.querySelectorAll(".sq")].forEach(s => s.classList.remove("hint"));
    const moves = chess.moves({ square: fromSq, verbose: true });
    for(const m of moves){
      const el = elBoard.querySelector(`.sq[data-sq="${m.to}"]`);
      if(el) el.classList.add("hint");
    }
  }

  // -----------------------------
  // Line Progress / Node Key
  // -----------------------------
  function getCurrentNodeFENKey(){
    // node key uses "startpos" when plyIndex === 0
    if(plyIndex === 0) return "startpos";
    return chess.fen();
  }

  function resetToLineStart(){
    chess = new Chess();
    selectedSquare = null;
    plyIndex = 0;
    historyFEN = ["startpos"];
    clearSys();
    setStatus(null, "å·²é‡ç½®ã€‚ä½ å¯ä»¥é–‹å§‹æ•™å­¸/ç·´ç¿’ã€‚");
    renderPosition();
  }

  function applySANMove(san){
    try{
      const move = chess.move(san, { sloppy: true });
      if(!move) return { ok:false, err:"éæ³•èµ°æ³•" };
      historyFEN.push(chess.fen());
      plyIndex++;
      return { ok:true, move };
    }catch(e){
      return { ok:false, err: String(e?.message || e) };
    }
  }

  function goNextLearn(){
    const nextSan = lineSAN[plyIndex]; // plyIndex=0 expects move0
    if(!nextSan){
      setStatus("ok","å·²åˆ°æ­¤è·¯ç·šçµå°¾ï¼ˆä½ å¯ä»¥åˆ‡åˆ°ç·´ç¿’æ¨¡å¼å†èµ°ä¸€æ¬¡ï¼‰ã€‚");
      logSys("ï¼ˆæ•™å­¸ï¼‰è·¯ç·šçµå°¾ã€‚");
      return;
    }
    const r = applySANMove(nextSan);
    if(!r.ok){
      setStatus("danger", `ç„¡æ³•å¥—ç”¨è·¯ç·šèµ°æ³•ï¼š${nextSan}ï¼ˆ${r.err}ï¼‰`);
      logSys(`å¥—ç”¨å¤±æ•—ï¼š${nextSan} / ${r.err}`);
      return;
    }
    setStatus("ok", `ï¼ˆæ•™å­¸ï¼‰å·²èµ°ï¼š${nextSan}`);
    logSys(`ï¼ˆæ•™å­¸ï¼‰ç³»çµ±èµ°ï¼š${nextSan}`);
    renderPosition();
  }

  function goPrev(){
    if(plyIndex <= 0){
      setStatus("warn","å·²åœ¨èµ·å§‹å±€é¢ã€‚");
      return;
    }
    // undo one move
    chess.undo();
    plyIndex--;
    historyFEN.pop();
    selectedSquare = null;
    setStatus(null, "å·²å›åˆ°ä¸Šä¸€æ­¥ã€‚");
    renderPosition();
  }

  // -----------------------------
  // Practice: validate vs expected + wrong move feedback
  // -----------------------------
  function validateMoveAgainstNode(playerSAN){
    const nodeKey = getCurrentNodeFENKey(); // BEFORE move applied in practice flow
    const node = getNodeByFEN(nodeKey);
    if(!node){
      return { kind:"warn", msg:"æ­¤å±€é¢æ²’æœ‰æ•™å­¸ç¯€é»è³‡æ–™ï¼šç³»çµ±åƒ…åšåˆæ³•æ€§åˆ¤æ–·ã€‚", node:null };
    }
    // wrong move match
    if(Array.isArray(node.wrong_moves)){
      const wm = node.wrong_moves.find(x => normalizeSAN(x.san) === normalizeSAN(playerSAN));
      if(wm){
        return {
          kind:"danger",
          msg:`âŒ å¸¸è¦‹éŒ¯èª¤ï¼š${wm.san}ï¼ˆ${wm.mistake_type}ï¼‰\nåŸå› ï¼š${wm.reason}`,
          node
        };
      }
    }
    // expected next
    if(Array.isArray(node.expected_next_san) && node.expected_next_san.length>0){
      const ok = node.expected_next_san.some(x => normalizeSAN(x) === normalizeSAN(playerSAN));
      if(ok){
        return { kind:"ok", msg:`âœ… æ­£ç¢ºï¼š${playerSAN}\né‡é»ï¼š${node.explanation || "â€”"}`, node };
      }
      return {
        kind:"warn",
        msg:`âš ï¸ ä¸æ˜¯æ­¤æ•™å­¸è·¯ç·šçš„æ¨è–¦è‘—æ³•ï¼šä½ ä¸‹äº† ${playerSAN}\nå»ºè­°ï¼š${node.expected_next_san.join(" æˆ– ")}`,
        node
      };
    }
    return { kind:"warn", msg:"æ­¤å±€é¢æ²’æœ‰è¨­å®š expected_next_sanã€‚", node };
  }

  function normalizeSAN(s){
    return (s || "").replace(/\s+/g,"").replace(/[+#?!]/g,"").toLowerCase();
  }

  function practiceMaybeAutoReply(){
    // ç³»çµ±æ‰®æ¼”å°æ‰‹ï¼šå¦‚æœè¼ªåˆ°å°æ‰‹ï¼Œä¸” line æœ‰ä¸‹ä¸€æ­¥ï¼Œå°±èµ° line çš„ä¸‹ä¸€æ­¥
    const sideToMove = chess.turn(); // 'w'/'b'
    const playerSide = curPracticeSide;
    if(sideToMove === playerSide) return;

    // æœŸå¾…ç³»çµ±èµ° line çš„ä¸‹ä¸€æ­¥ï¼ˆä¾ plyIndexï¼‰
    const nextSan = lineSAN[plyIndex];
    if(!nextSan){
      setStatus("ok","ç·´ç¿’åˆ°è·¯ç·šçµå°¾ï¼ˆä½ å¯ä»¥é‡ç½®æˆ–æ›åˆ†æ”¯ï¼‰ã€‚");
      logSys("ï¼ˆç·´ç¿’ï¼‰è·¯ç·šçµå°¾ã€‚");
      return;
    }
    const r = applySANMove(nextSan);
    if(!r.ok){
      setStatus("danger", `å°æ‰‹èµ°æ³•å¥—ç”¨å¤±æ•—ï¼š${nextSan}ï¼ˆ${r.err}ï¼‰`);
      logSys(`ï¼ˆç·´ç¿’ï¼‰å°æ‰‹èµ°å¤±æ•—ï¼š${nextSan} / ${r.err}`);
      return;
    }
    logSys(`ï¼ˆç·´ç¿’ï¼‰å°æ‰‹èµ°ï¼š${nextSan}`);
    renderPosition();
  }

  // -----------------------------
  // Click-to-move
  // -----------------------------
  function onSquareClick(e){
    const sq = e.currentTarget.dataset.sq;
    if(!sq) return;

    // quiz mode: board still clickable, but keep behavior consistent
    // learn mode: ignore manual moves (use next/prev)
    if(curMode === "learn"){
      setStatus("warn","æ•™å­¸æ¨¡å¼è«‹ç”¨ã€Œä¸‹ä¸€æ­¥/ä¸Šä¸€æ­¥ã€ï¼Œé¿å…ç ´å£è·¯ç·šã€‚");
      return;
    }

    // practice mode: only allow moving if it's player's turn
    if(curMode === "practice"){
      if(chess.turn() !== curPracticeSide){
        setStatus("warn","ç¾åœ¨è¼ªåˆ°ç³»çµ±/å°æ‰‹èµ°ã€‚");
        return;
      }
    }

    const el = elBoard.querySelector(`.sq[data-sq="${sq}"]`);
    if(!selectedSquare){
      // select
      selectedSquare = sq;
      [...elBoard.querySelectorAll(".sq")].forEach(s => s.classList.remove("sel"));
      if(el) el.classList.add("sel");
      highlightMoves(sq);
      return;
    }

    // attempt move selectedSquare -> sq
    const from = selectedSquare;
    const to = sq;

    // clear selection
    selectedSquare = null;
    [...elBoard.querySelectorAll(".sq")].forEach(s => s.classList.remove("sel","hint"));

    // capture node key BEFORE applying (for validation)
    const nodeKeyBefore = getCurrentNodeFENKey();

    // try move
    let moveObj = null;
    try{
      moveObj = chess.move({ from, to, promotion: "q" }); // simple auto queen promotion
    }catch(_){}
    if(!moveObj){
      setStatus("danger", `éæ³•èµ°æ³•ï¼š${from} â†’ ${to}`);
      logSys(`éæ³•èµ°æ³•ï¼š${from}â†’${to}`);
      // restore explanation for current node
      renderPosition();
      return;
    }

    // update plyIndex/history
    historyFEN.push(chess.fen());
    plyIndex++;

    const playerSAN = moveObj.san;

    if(curMode === "practice"){
      // validate vs node BEFORE move (nodeKeyBefore)
      const node = getNodeByFEN(nodeKeyBefore);
      let verdict = { kind:"warn", msg:"â€”" };
      if(node){
        // temporarily validate against nodeKeyBefore by injecting into helper
        // easiest: revert reading current node by passing playerSAN w/ node from before
        // We'll reuse validateMoveAgainstNode by setting a custom lookup
        verdict = (function(){
          // validate against explicit node
          // wrong
          if(Array.isArray(node.wrong_moves)){
            const wm = node.wrong_moves.find(x => normalizeSAN(x.san) === normalizeSAN(playerSAN));
            if(wm){
              return {
                kind:"danger",
                msg:`âŒ å¸¸è¦‹éŒ¯èª¤ï¼š${wm.san}ï¼ˆ${wm.mistake_type}ï¼‰\nåŸå› ï¼š${wm.reason}`
              };
            }
          }
          if(Array.isArray(node.expected_next_san) && node.expected_next_san.length>0){
            const ok = node.expected_next_san.some(x => normalizeSAN(x) === normalizeSAN(playerSAN));
            if(ok){
              return { kind:"ok", msg:`âœ… æ­£ç¢ºï¼š${playerSAN}\né‡é»ï¼š${node.explanation || "â€”"}` };
            }
            return { kind:"warn", msg:`âš ï¸ éæ¨è–¦è‘—æ³•ï¼š${playerSAN}\nå»ºè­°ï¼š${node.expected_next_san.join(" æˆ– ")}` };
          }
          return { kind:"warn", msg:`ä½ ä¸‹äº†ï¼š${playerSAN}\nï¼ˆæ­¤å±€é¢æœªé…ç½® expected_next_sanï¼‰` };
        })();
      }else{
        verdict = { kind:"warn", msg:`ä½ ä¸‹äº†ï¼š${playerSAN}\nï¼ˆæ­¤å±€é¢å°šæœªæœ‰æ•™å­¸ç¯€é»è³‡æ–™ï¼‰` };
      }

      setStatus(verdict.kind, verdict.msg);
      logSys(`ï¼ˆç·´ç¿’ï¼‰ä½ èµ°ï¼š${playerSAN}`);

      renderPosition();

      // auto reply by line
      practiceMaybeAutoReply();
      return;
    }

    // quiz mode: still allow free play, but show status only
    setStatus("ok", `ä½ èµ°ï¼š${playerSAN}`);
    logSys(`ï¼ˆè‡ªç”±ï¼‰ä½ èµ°ï¼š${playerSAN}`);
    renderPosition();
  }

  // -----------------------------
  // Quiz rendering
  // -----------------------------
  function renderQuiz(node){
    elQuizBox.style.display = "block";
    elQuizFeedback.textContent = "â€”";
    elQuizChoices.innerHTML = "";

    const ex = node?.exercise;
    if(!ex){
      elQuizPrompt.textContent = "ï¼ˆæ­¤å±€é¢æ²’æœ‰é…ç½®æ¸¬é©—ï¼‰";
      return;
    }

    elQuizPrompt.textContent = ex.prompt;

    for(const c of ex.choices){
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.textContent = c;
      btn.addEventListener("click", () => {
        const correct = (c === ex.correct);
        elQuizFeedback.textContent = correct ? `âœ… æ­£ç¢ºï¼${ex.feedback}` : `âŒ ä¸æ­£ç¢ºã€‚æç¤ºï¼š${ex.feedback}`;
        setStatus(correct ? "ok" : "warn", correct ? "æ¸¬é©—ç­”å°ã€‚" : "æ¸¬é©—ç­”éŒ¯ï¼Œå†æƒ³æƒ³ã€‚");
      });
      elQuizChoices.appendChild(btn);
    }
  }

  // -----------------------------
  // Wiring: selectors & buttons
  // -----------------------------
  function populateOpenings(){
    elOpening.innerHTML = "";
    for(const op of DATA.openings){
      const opt = document.createElement("option");
      opt.value = op.opening_id;
      opt.textContent = `${op.name}ï¼ˆECO: ${op.eco}ï½œ${op.difficulty}ï¼‰`;
      elOpening.appendChild(opt);
    }
    curOpeningId = DATA.openings[0]?.opening_id || null;
    elOpening.value = curOpeningId || "";
  }

  function populateLines(){
    elLine.innerHTML = "";
    const lines = getLinesByOpening(curOpeningId);
    for(const li of lines){
      const opt = document.createElement("option");
      opt.value = li.line_id;
      opt.textContent = `${li.name}`;
      elLine.appendChild(opt);
    }
    curLineId = lines[0]?.line_id || null;
    elLine.value = curLineId || "";
  }

  function loadLine(){
    const li = getLine(curLineId);
    if(!li){
      setStatus("danger","æ‰¾ä¸åˆ°è·¯ç·šè³‡æ–™ã€‚");
      return;
    }
    lineSAN = li.move_sequence_san.slice();
    resetToLineStart();

    const op = getOpening(curOpeningId);
    updateHeadline();
    setStatus(null, `å·²è¼‰å…¥ï¼š${op?.name || ""} / ${li.name}`);
    logSys(`è¼‰å…¥è·¯ç·šï¼š${li.line_id}`);
  }

  elOpening.addEventListener("change", () => {
    curOpeningId = elOpening.value;
    populateLines();
    loadLine();
  });

  elLine.addEventListener("change", () => {
    curLineId = elLine.value;
    loadLine();
  });

  elMode.addEventListener("change", () => {
    curMode = elMode.value;
    clearSys();
    selectedSquare = null;
    renderPosition();

    if(curMode === "learn"){
      setStatus(null,"æ•™å­¸æ¨¡å¼ï¼šç”¨ã€Œä¸‹ä¸€æ­¥/ä¸Šä¸€æ­¥ã€é€æ­¥çœ‹è§£èªªã€‚");
    }else if(curMode === "practice"){
      setStatus(null,"ç·´ç¿’æ¨¡å¼ï¼šé»é¸æ£‹å­ â†’ é»ç›®æ¨™æ ¼ä¸‹æ£‹ã€‚ç³»çµ±æœƒå›é¥‹ã€æ­£ç¢º/éæ¨è–¦/å¸¸è¦‹éŒ¯èª¤ã€ã€‚");
      // practice mode might require auto reply if player chose to be black
      practiceMaybeAutoReply();
    }else{
      setStatus(null,"æ¸¬é©—æ¨¡å¼ï¼šçœ‹å±€é¢è§£èªªï¼Œå›ç­”æ¦‚å¿µé¸æ“‡é¡Œï¼ˆè‹¥è©²å±€é¢æœ‰é…ç½®ï¼‰ã€‚æ£‹ç›¤ä»å¯è‡ªç”±èµ°ã€‚");
    }
  });

  elSide.addEventListener("change", () => {
    curPracticeSide = elSide.value;
    if(curMode === "practice"){
      setStatus(null, `ç·´ç¿’æ¨¡å¼ï¼šä½ æ‰®æ¼” ${curPracticeSide==="w"?"ç™½æ–¹":"é»‘æ–¹"}ã€‚`);
      practiceMaybeAutoReply();
    }
  });

  elReset.addEventListener("click", () => {
    loadLine();
    if(curMode === "practice"){
      practiceMaybeAutoReply();
    }
  });

  elPrev.addEventListener("click", () => {
    goPrev();
  });

  elNext.addEventListener("click", () => {
    if(curMode !== "learn"){
      setStatus("warn","ã€Œä¸‹ä¸€æ­¥ã€ä¸»è¦ç”¨æ–¼æ•™å­¸æ¨¡å¼ã€‚ç·´ç¿’æ¨¡å¼è«‹ç›´æ¥åœ¨æ£‹ç›¤ä¸Šèµ°ã€‚");
      return;
    }
    goNextLearn();
  });

  // -----------------------------
  // Init
  // -----------------------------
  buildBoard();
  populateOpenings();
  populateLines();
  loadLine();
  renderPosition();
  setStatus(null,"æ•™å­¸æ¨¡å¼ï¼šæŒ‰ã€Œä¸‹ä¸€æ­¥ã€é–‹å§‹ã€‚ç·´ç¿’æ¨¡å¼ï¼šç›´æ¥åœ¨æ£‹ç›¤ä¸Šé»é¸èµ°å­ã€‚");
</script>
</body>
</html>