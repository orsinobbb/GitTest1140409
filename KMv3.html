<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>çŸ¥è­˜åœ–è­œäº’å‹•ç³»çµ± v3 - æ‹“æ¨¸è¦–åœ–</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      text-align: center;
      color: white;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 10px;
    }
    .controls {
      max-width: 1200px;
      margin: 0 auto 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .controls input {
      flex: 1;
      min-width: 200px;
      padding: 12px 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 1em;
    }
    .controls button {
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9em;
    }
    .btn-search {
      background: white;
      color: #667eea;
    }
    .btn-view {
      background: #9c27b0;
      color: white;
    }
    .btn-export {
      background: #28a745;
      color: white;
    }
    .btn-import {
      background: #17a2b8;
      color: white;
    }
    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .graph-container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      min-height: 600px;
      position: relative;
    }
    .topology {
      width: 100%;
      height: 600px;
      position: relative;
    }
    .node {
      position: absolute;
      padding: 12px 20px;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      user-select: none;
      z-index: 10;
    }
    .node:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      z-index: 20;
    }
    .node.current {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 1.3em;
      padding: 18px 30px;
      z-index: 15;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .node.upstream {
      background: #ffc107;
      color: #000;
      border: 3px solid #ff9800;
    }
    .node.downstream {
      background: #e3f2fd;
      color: #1976d2;
      border: 2px solid #64b5f6;
    }
    .node.exists {
      background: #c8e6c9;
      border-color: #66bb6a;
    }
    .node.generating {
      background: #ffe0b2;
      border: 2px dashed #ff9800;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .connection {
      position: absolute;
      height: 2px;
      background: #ddd;
      transform-origin: left center;
      z-index: 0;
      pointer-events: none;
    }
    .connection.upstream {
      background: #ffc107;
      height: 3px;
      z-index: 0;
    }
    .tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      max-width: 400px;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      line-height: 1.6;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 193, 7, 0.3);
    }
    .tooltip.show {
      opacity: 1;
    }
    .tooltip-title {
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 1.1em;
      color: #ffc107;
    }
    .stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      font-size: 0.85em;
    }
    .stat-item {
      margin-bottom: 5px;
    }
    .stat-value {
      font-weight: 600;
      color: #667eea;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .loading-overlay.show {
      display: flex;
    }
    .loading-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    input[type="file"] {
      display: none;
    }
    
    /* å®Œæ•´æ‹“æ¨¸è¦–åœ–æ¨£å¼ */
    .full-view-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: none;
      overflow: hidden;
    }
    .full-view-overlay.show {
      display: block;
    }
    .full-view-wrapper {
      width: 100%;
      height: 100%;
      overflow: auto;
      cursor: grab;
      position: relative;
    }
    .full-view-wrapper.dragging {
      cursor: grabbing;
    }
    .full-view-container {
      min-width: 2000px;
      min-height: 1500px;
      position: relative;
      padding: 100px;
      transform-origin: 0 0;
    }
    .full-view-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(102, 126, 234, 0.95);
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 2001;
      backdrop-filter: blur(10px);
    }
    .full-view-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .zoom-btn {
      background: white;
      color: #667eea;
      border: none;
      padding: 8px 15px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1em;
    }
    .zoom-btn:hover {
      background: #f0f0f0;
    }
    .zoom-level {
      color: white;
      font-weight: 600;
      min-width: 60px;
      text-align: center;
    }
    .full-view-title {
      color: white;
      font-size: 1.3em;
      font-weight: 600;
    }
    .full-view-close {
      background: white;
      color: #667eea;
      border: none;
      padding: 10px 25px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1em;
    }
    .full-view-close:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
    }
    .full-view-node {
      position: absolute;
      padding: 10px 18px;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      font-size: 0.9em;
      z-index: 10;
    }
    .full-view-node:hover {
      transform: scale(1.15);
      z-index: 20;
    }
    .full-view-node.local {
      background: #c8e6c9;
      color: #1b5e20;
      border: 2px solid #66bb6a;
    }
    .full-view-node.ai {
      background: #e3f2fd;
      color: #0d47a1;
      border: 2px solid #64b5f6;
    }
    .full-view-connection {
      position: absolute;
      height: 1px;
      background: rgba(255, 255, 255, 0.3);
      transform-origin: left center;
      z-index: 0;
      pointer-events: none;
    }
    .full-view-legend {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 2001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.85em;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }
    .api-status {
      position: absolute;
      top: 20px;
      left: 20px;
      background: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.85em;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .api-status.ready {
      border-left: 4px solid #28a745;
    }
    .api-status.missing {
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ§  çŸ¥è­˜åœ–è­œäº’å‹•ç³»çµ±</h1>
    <div>v3.0 - æ‹“æ¨¸è¦–è¦ºåŒ– | é»æ“Šç¯€é»åˆ‡æ›è¦–åœ– | æ»‘é¼ ç§»éé¡¯ç¤ºèªªæ˜</div>
  </div>

  <div class="controls">
    <input type="text" id="apiKey" placeholder="Google Gemini API Key (AIza...)">
    <input type="text" id="searchInput" placeholder="æœå°‹ç¯€é»æˆ–è¼¸å…¥æ–°æ¦‚å¿µ...">
    <button class="btn-search" onclick="searchNode()">ğŸ” æœå°‹</button>
    <button class="btn-view" onclick="toggleFullView()">ğŸ—ºï¸ å®Œæ•´æ‹“æ¨¸</button>
    <button class="btn-export" onclick="exportGraph()">ğŸ’¾ åŒ¯å‡º</button>
    <button class="btn-import" onclick="document.getElementById('importFile').click()">ğŸ“‚ åŒ¯å…¥</button>
  </div>
  <input type="file" id="importFile" accept=".json" onchange="importGraph(event)">

  <div class="graph-container">
    <div class="api-status" id="apiStatus">
      <span id="apiStatusText">âš ï¸ è«‹è¨­å®š API Key</span>
    </div>
    
    <div class="stats">
      <div class="stat-item">ç¯€é»ç¸½æ•¸: <span class="stat-value" id="totalNodes">6</span></div>
      <div class="stat-item">æœ¬åœ°: <span class="stat-value" id="localNodes">6</span></div>
      <div class="stat-item">AIç”Ÿæˆ: <span class="stat-value" id="aiNodes">0</span></div>
    </div>

    <div class="topology" id="topology"></div>
    <div class="tooltip" id="tooltip">
      <div class="tooltip-title" id="tooltipTitle"></div>
      <div id="tooltipContent"></div>
    </div>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div>æ­£åœ¨å‘¼å« AI ç”Ÿæˆç¯€é»...</div>
    </div>
  </div>

  <!-- å®Œæ•´æ‹“æ¨¸è¦–åœ– -->
  <div class="full-view-overlay" id="fullViewOverlay">
    <div class="full-view-header">
      <div class="full-view-title">ğŸ—ºï¸ å®Œæ•´çŸ¥è­˜åœ–è­œæ‹“æ¨¸</div>
      <div class="full-view-controls">
        <button class="zoom-btn" onclick="zoomFullView(-0.1)">ğŸ”âˆ’</button>
        <div class="zoom-level" id="zoomLevel">100%</div>
        <button class="zoom-btn" onclick="zoomFullView(0.1)">ğŸ”+</button>
        <button class="zoom-btn" onclick="resetFullView()">ğŸ”„ é‡ç½®</button>
        <button class="full-view-close" onclick="toggleFullView()">âœ• é—œé–‰</button>
      </div>
    </div>
    <div class="full-view-wrapper" id="fullViewWrapper">
      <div class="full-view-container" id="fullViewContainer"></div>
    </div>
    <div class="full-view-legend">
      <div style="font-weight: 600; margin-bottom: 10px;">åœ–ä¾‹</div>
      <div class="legend-item">
        <div class="legend-color" style="background: #c8e6c9; border: 2px solid #66bb6a;"></div>
        <span>æœ¬åœ°ç¯€é»</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #e3f2fd; border: 2px solid #64b5f6;"></div>
        <span>AI ç”Ÿæˆç¯€é»</span>
      </div>
      <div style="margin-top: 10px; font-size: 0.8em; color: #666;">
        ğŸ’¡ å¯æ‹–æ›³ç§»å‹•<br>
        ğŸ’¡ æ»¾è¼ªç¸®æ”¾
      </div>
    </div>
  </div>

  <script>
    // ===== çŸ¥è­˜åœ–è­œè³‡æ–™ =====
    let knowledgeGraph = {
      "äººå·¥æ™ºæ…§": {
        content: "äººå·¥æ™ºæ…§ï¼ˆAIï¼‰æ˜¯è®“æ©Ÿå™¨å±•ç¾æ™ºæ…§è¡Œç‚ºçš„æŠ€è¡“ï¼ŒåŒ…æ‹¬å­¸ç¿’ã€æ¨ç†ã€è‡ªæˆ‘ä¿®æ­£ç­‰èƒ½åŠ›ã€‚æ©Ÿå™¨å­¸ç¿’æ˜¯å¯¦ç¾ AI çš„é‡è¦æ–¹æ³•ä¹‹ä¸€ã€‚",
        downstream: ["æ©Ÿå™¨å­¸ç¿’", "å°ˆå®¶ç³»çµ±", "é›»è…¦è¦–è¦º"],
        upstream: [],
        source: "local"
      },
      "æ©Ÿå™¨å­¸ç¿’": {
        content: "æ©Ÿå™¨å­¸ç¿’æ˜¯äººå·¥æ™ºæ…§çš„ä¸€å€‹åˆ†æ”¯ï¼Œé€éæ¼”ç®—æ³•è®“é›»è…¦å¾è³‡æ–™ä¸­å­¸ç¿’è¦å¾‹ï¼Œç„¡éœ€æ˜ç¢ºç·¨ç¨‹ã€‚å¸¸è¦‹æ‡‰ç”¨åŒ…æ‹¬å½±åƒè¾¨è­˜ã€èªéŸ³è¾¨è­˜ã€æ¨è–¦ç³»çµ±ç­‰ã€‚",
        downstream: ["æ·±åº¦å­¸ç¿’", "ç›£ç£å¼å­¸ç¿’", "éç›£ç£å¼å­¸ç¿’"],
        upstream: ["äººå·¥æ™ºæ…§"],
        source: "local"
      },
      "æ·±åº¦å­¸ç¿’": {
        content: "æ·±åº¦å­¸ç¿’æ˜¯æ©Ÿå™¨å­¸ç¿’çš„å­é ˜åŸŸï¼Œä½¿ç”¨å¤šå±¤ç¥ç¶“ç¶²è·¯æ¨¡æ“¬äººè…¦é‹ä½œã€‚ç‰¹åˆ¥æ“…é•·è™•ç†å½±åƒã€èªéŸ³ã€è‡ªç„¶èªè¨€ç­‰éçµæ§‹åŒ–è³‡æ–™ã€‚",
        downstream: ["ç¥ç¶“ç¶²è·¯", "å·ç©ç¥ç¶“ç¶²è·¯", "å¾ªç’°ç¥ç¶“ç¶²è·¯"],
        upstream: ["æ©Ÿå™¨å­¸ç¿’"],
        source: "local"
      },
      "ç¥ç¶“ç¶²è·¯": {
        content: "ç¥ç¶“ç¶²è·¯ç”±å¤šå€‹äº’ç›¸é€£æ¥çš„ç¥ç¶“å…ƒçµ„æˆï¼Œé€éæ¬Šé‡èª¿æ•´ä¾†å­¸ç¿’è³‡æ–™ç‰¹å¾µã€‚æ˜¯æ·±åº¦å­¸ç¿’çš„åŸºç¤æ¶æ§‹ã€‚",
        downstream: ["æ„ŸçŸ¥å™¨", "å•Ÿå‹•å‡½æ•¸", "åå‘å‚³æ’­"],
        upstream: ["æ·±åº¦å­¸ç¿’"],
        source: "local"
      },
      "ç›£ç£å¼å­¸ç¿’": {
        content: "ç›£ç£å¼å­¸ç¿’ä½¿ç”¨æ¨™è¨˜å¥½çš„è¨“ç·´è³‡æ–™ï¼Œè®“æ¨¡å‹å­¸ç¿’è¼¸å…¥èˆ‡è¼¸å‡ºä¹‹é–“çš„å°æ‡‰é—œä¿‚ã€‚å¸¸è¦‹æ¼”ç®—æ³•åŒ…æ‹¬ç·šæ€§è¿´æ­¸ã€æ±ºç­–æ¨¹ã€æ”¯æ´å‘é‡æ©Ÿç­‰ã€‚",
        downstream: ["ç·šæ€§è¿´æ­¸", "æ±ºç­–æ¨¹", "æ”¯æ´å‘é‡æ©Ÿ"],
        upstream: ["æ©Ÿå™¨å­¸ç¿’"],
        source: "local"
      },
      "éç›£ç£å¼å­¸ç¿’": {
        content: "éç›£ç£å¼å­¸ç¿’è™•ç†æœªæ¨™è¨˜çš„è³‡æ–™ï¼Œç›®æ¨™æ˜¯ç™¼ç¾è³‡æ–™ä¸­çš„éš±è—çµæ§‹æˆ–æ¨¡å¼ã€‚å¸¸è¦‹æ–¹æ³•åŒ…æ‹¬èšé¡åˆ†æã€é™ç¶­ç­‰ã€‚",
        downstream: ["K-means", "ä¸»æˆåˆ†åˆ†æ"],
        upstream: ["æ©Ÿå™¨å­¸ç¿’"],
        source: "local"
      }
    };

    let currentNode = "æ©Ÿå™¨å­¸ç¿’";
    const apiKeyInput = document.getElementById('apiKey');
    const tooltip = document.getElementById('tooltip');

    // ===== æ›´æ–°çµ±è¨ˆ =====
    function updateStats() {
      const total = Object.keys(knowledgeGraph).length;
      const local = Object.values(knowledgeGraph).filter(n => n.source === 'local').length;
      document.getElementById('totalNodes').textContent = total;
      document.getElementById('localNodes').textContent = local;
      document.getElementById('aiNodes').textContent = total - local;
      
      // æ›´æ–° API ç‹€æ…‹
      const apiStatus = document.getElementById('apiStatus');
      const apiStatusText = document.getElementById('apiStatusText');
      if (apiKeyInput.value.trim()) {
        apiStatus.className = 'api-status ready';
        apiStatusText.textContent = 'âœ… API å·²è¨­å®š';
      } else {
        apiStatus.className = 'api-status missing';
        apiStatusText.textContent = 'âš ï¸ è«‹è¨­å®š API Key';
      }
    }

    // ===== å‘¼å« LLM API =====
    async function callLLM(concept) {
      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        throw new Error('è«‹å…ˆè¨­å®š API Key');
      }

      const prompt = `è«‹ç”¨ç¹é«”ä¸­æ–‡ä»‹ç´¹ã€Œ${concept}ã€é€™å€‹æ¦‚å¿µï¼Œä¸¦æä¾›ï¼š
1. ç°¡çŸ­èªªæ˜ï¼ˆ2-3å¥è©±ï¼‰
2. 3å€‹ç›¸é—œçš„ä¸‹æ¸¸æ¦‚å¿µï¼ˆæ›´å…·é«”çš„å­æ¦‚å¿µï¼‰
3. 1å€‹ä¸Šæ¸¸æ¦‚å¿µï¼ˆæ›´æŠ½è±¡çš„çˆ¶æ¦‚å¿µï¼Œå¦‚æœé€™å·²ç¶“æ˜¯æœ€é ‚å±¤æ¦‚å¿µå‰‡ç•™ç©ºé™£åˆ—ï¼‰
4. æ¯å€‹ä¸‹æ¸¸æ¦‚å¿µçš„ç°¡çŸ­èªªæ˜ï¼ˆ1-2å¥è©±ï¼‰

è«‹ä»¥ JSON æ ¼å¼å›æ‡‰ï¼š
{
  "content": "èªªæ˜æ–‡å­—",
  "downstream": [
    {"name": "æ¦‚å¿µ1", "content": "æ¦‚å¿µ1çš„èªªæ˜"},
    {"name": "æ¦‚å¿µ2", "content": "æ¦‚å¿µ2çš„èªªæ˜"},
    {"name": "æ¦‚å¿µ3", "content": "æ¦‚å¿µ3çš„èªªæ˜"}
  ],
  "upstream": ["æ¦‚å¿µA"]
}`;

      const model = "gemini-2.5-flash";
      const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: { temperature: 0.7, maxOutputTokens: 2048 }
        })
      });

      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error?.message || 'API å‘¼å«å¤±æ•—');
      }

      if (data.candidates && data.candidates.length > 0) {
        const text = data.candidates[0].content.parts[0].text;
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          return JSON.parse(jsonMatch[0]);
        }
      }
      throw new Error('ç„¡æ³•è§£æ AI å›æ‡‰');
    }

    // ===== ç¹ªè£½é€£æ¥ç·š =====
    function drawConnection(fromX, fromY, toX, toY, isUpstream = false) {
      const dx = toX - fromX;
      const dy = toY - fromY;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;

      const line = document.createElement('div');
      line.className = isUpstream ? 'connection upstream' : 'connection';
      line.style.width = length + 'px';
      line.style.left = fromX + 'px';
      line.style.top = fromY + 'px';
      line.style.transform = `rotate(${angle}deg)`;
      
      return line;
    }

    // ===== æ¸²æŸ“æ‹“æ¨¸åœ– =====
    function renderTopology() {
      const topology = document.getElementById('topology');
      topology.innerHTML = '';

      const nodeData = knowledgeGraph[currentNode];
      if (!nodeData) {
        topology.innerHTML = '<div style="text-align: center; padding: 50px; color: #999;">ç¯€é»ä¸å­˜åœ¨</div>';
        return;
      }

      const centerX = 600;
      const centerY = 300;

      // ç¹ªè£½ç•¶å‰ç¯€é»ï¼ˆä¸­å¿ƒï¼‰
      const currentEl = createNode(currentNode, centerX, centerY, 'current');
      topology.appendChild(currentEl);

      // ç¹ªè£½ä¸Šæ¸¸ç¯€é»ï¼ˆå·¦ä¸Šï¼‰- å¿…å®šå·²å­˜åœ¨
      const upstream = nodeData.upstream || [];
      if (upstream.length > 0) {
        upstream.forEach((name, i) => {
          // æª¢æŸ¥ä¸Šæ¸¸ç¯€é»æ˜¯å¦å­˜åœ¨
          if (!knowledgeGraph[name]) {
            console.warn(`âš ï¸ ä¸Šæ¸¸ç¯€é»ã€Œ${name}ã€ä¸å­˜åœ¨æ–¼åœ–è­œä¸­ï¼Œè«‹æª¢æŸ¥è³‡æ–™å®Œæ•´æ€§`);
            return; // è·³éä¸å­˜åœ¨çš„ä¸Šæ¸¸ç¯€é»
          }
          
          const x = centerX - 280;
          const y = centerY - 100 + (i * 70);
          const node = createNode(name, x, y, 'upstream');
          topology.appendChild(node);
          
          // ç¹ªè£½é€£æ¥ç·šï¼ˆå¾ä¸Šæ¸¸æŒ‡å‘ç•¶å‰ç¯€é»ï¼‰
          topology.appendChild(drawConnection(x + 80, y + 20, centerX - 30, centerY + 20, true));
        });
      }

      // ç¹ªè£½ä¸‹æ¸¸ç¯€é»ï¼ˆç’°ç¹ï¼‰
      const downstream = nodeData.downstream || [];
      if (downstream.length > 0) {
        const radius = 220;
        const angleStep = (2 * Math.PI) / downstream.length;
        const startAngle = -Math.PI / 2; // å¾ä¸Šæ–¹é–‹å§‹

        downstream.forEach((name, i) => {
          const angle = startAngle + angleStep * i;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          
          // åˆ¤æ–·ç¯€é»æ˜¯å¦å·²å­˜åœ¨
          const className = knowledgeGraph[name] ? 'exists' : 'downstream';
          const node = createNode(name, x, y, className);
          topology.appendChild(node);
          
          // ç¹ªè£½é€£æ¥ç·šï¼ˆå¾ç•¶å‰ç¯€é»æŒ‡å‘ä¸‹æ¸¸ï¼‰
          topology.appendChild(drawConnection(centerX + 30, centerY + 20, x, y + 20));
        });
      }

      updateStats();
    }

    // ===== å»ºç«‹ç¯€é»å…ƒç´  =====
    function createNode(name, x, y, className) {
      const node = document.createElement('div');
      node.className = `node ${className}`;
      node.textContent = name;
      node.style.left = (x - 50) + 'px';
      node.style.top = (y - 20) + 'px';

      // é»æ“Šäº‹ä»¶ - å‚³éä¾†æºç¯€é»è³‡è¨Š
      node.addEventListener('click', () => {
        // å¦‚æœé»æ“Šçš„æ˜¯ä¸‹æ¸¸ç¯€é»ï¼Œå‚³éç•¶å‰ç¯€é»ä½œç‚ºä¾†æº
        const isDownstream = knowledgeGraph[currentNode]?.downstream?.includes(name);
        handleNodeClick(name, isDownstream ? currentNode : null);
      });

      // æ»‘é¼ ç§»å…¥é¡¯ç¤ºèªªæ˜
      node.addEventListener('mouseenter', (e) => {
        if (knowledgeGraph[name]) {
          const rect = node.getBoundingClientRect();
          
          tooltip.querySelector('#tooltipTitle').textContent = name;
          tooltip.querySelector('#tooltipContent').textContent = knowledgeGraph[name].content;
          
          // è¨ˆç®— tooltip ä½ç½®ï¼šå„ªå…ˆé¡¯ç¤ºåœ¨ç¯€é»å³å´ï¼Œå¦‚æœè¶…å‡ºè¦–çª—å‰‡é¡¯ç¤ºåœ¨å·¦å´
          const tooltipWidth = 400; // tooltip çš„æœ€å¤§å¯¬åº¦
          const showOnRight = (rect.right + tooltipWidth + 20) < window.innerWidth;
          
          if (showOnRight) {
            // é¡¯ç¤ºåœ¨å³å´
            tooltip.style.left = (rect.right + 10) + 'px';
          } else {
            // é¡¯ç¤ºåœ¨å·¦å´
            tooltip.style.left = (rect.left - tooltipWidth - 10) + 'px';
          }
          
          // å‚ç›´ä½ç½®ï¼šèˆ‡ç¯€é»é ‚éƒ¨å°é½Š
          tooltip.style.top = rect.top + 'px';
          tooltip.classList.add('show');
        }
      });

      node.addEventListener('mouseleave', () => {
        tooltip.classList.remove('show');
      });

      return node;
    }

    // ===== è™•ç†ç¯€é»é»æ“Š =====
    async function handleNodeClick(name, sourceNode = null) {
      // æª¢æŸ¥ç¯€é»æ˜¯å¦å­˜åœ¨
      const nodeExists = knowledgeGraph[name];
      
      if (!nodeExists) {
        // ç¯€é»ä¸å­˜åœ¨ï¼Œå‘¼å« API ç”Ÿæˆ
        document.getElementById('loadingOverlay').classList.add('show');
        
        try {
          const data = await callLLM(name);
          
          // å¼·åˆ¶ä½¿ç”¨ä¾†æºç¯€é»ä½œç‚ºä¸Šæ¸¸
          const correctUpstream = sourceNode ? [sourceNode] : (data.upstream || []);
          
          // è™•ç†ä¸‹æ¸¸è³‡æ–™æ ¼å¼
          let downstreamNames = [];
          if (data.downstream && data.downstream.length > 0) {
            if (typeof data.downstream[0] === 'string') {
              downstreamNames = data.downstream;
            } else if (typeof data.downstream[0] === 'object') {
              downstreamNames = data.downstream.map(d => d.name);
              
              // é å…ˆç”Ÿæˆä¸‹æ¸¸ç¯€é»
              data.downstream.forEach(downstreamNode => {
                if (!knowledgeGraph[downstreamNode.name]) {
                  knowledgeGraph[downstreamNode.name] = {
                    content: downstreamNode.content,
                    downstream: [],  // å…ˆè¨­ç‚ºç©ºï¼Œé»æ“Šæ™‚å†ç”Ÿæˆ
                    upstream: [name],
                    source: 'ai'
                  };
                  console.log(`  âœ… é å…ˆç”Ÿæˆä¸‹æ¸¸ç¯€é»: ${downstreamNode.name}`);
                }
              });
            }
          }
          
          // å„²å­˜ç•¶å‰ç¯€é»
          knowledgeGraph[name] = {
            content: data.content,
            downstream: downstreamNames,
            upstream: correctUpstream,
            source: 'ai'
          };
          
          console.log(`âœ… AI ç”Ÿæˆæ–°ç¯€é»: ${name}`);
          console.log(`ğŸ“ ä¸Šæ¸¸è¨­å®šç‚º: ${correctUpstream.join(', ') || '(é ‚å±¤ç¯€é»)'}`);
          console.log(`ğŸ“¦ ä¸‹æ¸¸ç¯€é»: ${downstreamNames.join(', ')}`);
          
        } catch (error) {
          alert('âŒ ç”Ÿæˆå¤±æ•—ï¼š' + error.message);
          document.getElementById('loadingOverlay').classList.remove('show');
          return;
        }
        
        document.getElementById('loadingOverlay').classList.remove('show');
      } else {
        // ç¯€é»å·²å­˜åœ¨
        console.log(`âœ… è®€å–å·²å­˜åœ¨ç¯€é»: ${name}`);
        
        // ğŸ”§ é—œéµä¿®æ­£ï¼šæª¢æŸ¥æ˜¯å¦éœ€è¦å±•é–‹ä¸‹æ¸¸
        const node = knowledgeGraph[name];
        if (node.downstream && node.downstream.length === 0 && node.source === 'ai') {
          // é€™æ˜¯ä¸€å€‹ AI ç”Ÿæˆçš„è‘‰ç¯€é»ï¼Œè©¢å•æ˜¯å¦è¦å±•é–‹
          const shouldExpand = confirm(`ã€Œ${name}ã€ç›®å‰æ²’æœ‰ä¸‹æ¸¸ç¯€é»ï¼Œæ˜¯å¦ä½¿ç”¨ AI ç”Ÿæˆä¸‹æ¸¸æ¦‚å¿µï¼Ÿ`);
          if (shouldExpand) {
            document.getElementById('loadingOverlay').classList.add('show');
            
            try {
              const data = await callLLM(name);
              
              // æ›´æ–°ä¸‹æ¸¸
              let downstreamNames = [];
              if (data.downstream && data.downstream.length > 0) {
                if (typeof data.downstream[0] === 'string') {
                  downstreamNames = data.downstream;
                } else if (typeof data.downstream[0] === 'object') {
                  downstreamNames = data.downstream.map(d => d.name);
                  
                  data.downstream.forEach(downstreamNode => {
                    if (!knowledgeGraph[downstreamNode.name]) {
                      knowledgeGraph[downstreamNode.name] = {
                        content: downstreamNode.content,
                        downstream: [],
                        upstream: [name],
                        source: 'ai'
                      };
                      console.log(`  âœ… é å…ˆç”Ÿæˆä¸‹æ¸¸ç¯€é»: ${downstreamNode.name}`);
                    }
                  });
                }
              }
              
              // æ›´æ–°ç•¶å‰ç¯€é»çš„ä¸‹æ¸¸
              knowledgeGraph[name].downstream = downstreamNames;
              console.log(`âœ… å±•é–‹ç¯€é»: ${name}`);
              console.log(`ğŸ“¦ æ–°å¢ä¸‹æ¸¸: ${downstreamNames.join(', ')}`);
              
            } catch (error) {
              alert('âŒ å±•é–‹å¤±æ•—ï¼š' + error.message);
            }
            
            document.getElementById('loadingOverlay').classList.remove('show');
          }
        }
      }

      // åˆ‡æ›åˆ°æ–°ç¯€é»
      currentNode = name;
      renderTopology();
      updateStats();
    }

    // ===== æœå°‹ç¯€é» =====
    function searchNode() {
      const query = document.getElementById('searchInput').value.trim();
      if (!query) return;

      if (knowledgeGraph[query]) {
        currentNode = query;
        renderTopology();
      } else {
        if (confirm(`ã€Œ${query}ã€ä¸å­˜åœ¨ï¼Œæ˜¯å¦ä½¿ç”¨ AI ç”Ÿæˆï¼Ÿ`)) {
          handleNodeClick(query, null);  // æ²’æœ‰ä¾†æºç¯€é»
        }
      }
    }

    // ===== åŒ¯å‡ºåœ–è­œ =====
    function exportGraph() {
      const dataStr = JSON.stringify(knowledgeGraph, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `knowledge_graph_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ===== åŒ¯å…¥åœ–è­œ =====
    function importGraph(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          knowledgeGraph = JSON.parse(e.target.result);
          renderTopology();
          alert('âœ… åœ–è­œå·²åŒ¯å…¥');
        } catch {
          alert('âŒ åŒ¯å…¥å¤±æ•—');
        }
      };
      reader.readAsText(file);
    }

    // ç›£è½ API Key è®ŠåŒ–
    apiKeyInput.addEventListener('input', updateStats);

    // ===== è³‡æ–™å®Œæ•´æ€§æª¢æŸ¥èˆ‡è‡ªå‹•ä¿®æ­£ =====
    function validateAndFixGraph() {
      const issues = [];
      const fixes = [];
      
      Object.keys(knowledgeGraph).forEach(nodeName => {
        const node = knowledgeGraph[nodeName];
        
        // æª¢æŸ¥ä¸¦ä¿®æ­£ä¸Šæ¸¸ç¯€é»
        if (node.upstream && node.upstream.length > 0) {
          const validUpstream = [];
          
          node.upstream.forEach(upstreamName => {
            if (!knowledgeGraph[upstreamName]) {
              issues.push(`âŒ ç¯€é»ã€Œ${nodeName}ã€çš„ä¸Šæ¸¸ã€Œ${upstreamName}ã€ä¸å­˜åœ¨`);
              
              // å˜—è©¦è‡ªå‹•ä¿®æ­£ï¼šå¾æ‰€æœ‰ç¯€é»ä¸­æ‰¾å‡ºåŒ…å«æ­¤ç¯€é»ä½œç‚ºä¸‹æ¸¸çš„ç¯€é»
              let found = false;
              Object.keys(knowledgeGraph).forEach(candidateName => {
                const candidate = knowledgeGraph[candidateName];
                if (candidate.downstream && candidate.downstream.includes(nodeName)) {
                  validUpstream.push(candidateName);
                  fixes.push(`âœ… è‡ªå‹•ä¿®æ­£ï¼šã€Œ${nodeName}ã€çš„ä¸Šæ¸¸æ”¹ç‚ºã€Œ${candidateName}ã€`);
                  found = true;
                }
              });
              
              if (!found) {
                console.warn(`âš ï¸ ç„¡æ³•è‡ªå‹•ä¿®æ­£ã€Œ${nodeName}ã€çš„ä¸Šæ¸¸ï¼Œå·²ç§»é™¤ã€Œ${upstreamName}ã€`);
              }
            } else {
              validUpstream.push(upstreamName);
            }
          });
          
          // æ›´æ–°ç‚ºæœ‰æ•ˆçš„ä¸Šæ¸¸åˆ—è¡¨
          node.upstream = validUpstream;
        }
      });
      
      if (fixes.length > 0) {
        console.log('ğŸ”§ è‡ªå‹•ä¿®æ­£å®Œæˆï¼š');
        fixes.forEach(fix => console.log(fix));
      }
      
      if (issues.length > 0) {
        console.warn('âš ï¸ è³‡æ–™å®Œæ•´æ€§å•é¡Œï¼ˆå·²ä¿®æ­£ï¼‰ï¼š');
        issues.forEach(issue => console.warn(issue));
        return false;
      } else {
        console.log('âœ… è³‡æ–™å®Œæ•´æ€§æª¢æŸ¥é€šé');
        return true;
      }
    }

    // åˆå§‹åŒ–
    validateAndFixGraph();
    renderTopology();

    // ===== å®Œæ•´æ‹“æ¨¸è¦–åœ– =====
    let fullViewScale = 1;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let scrollStartX = 0;
    let scrollStartY = 0;

    function toggleFullView() {
      const overlay = document.getElementById('fullViewOverlay');
      const isShowing = overlay.classList.contains('show');
      
      if (isShowing) {
        overlay.classList.remove('show');
      } else {
        renderFullTopology();
        overlay.classList.add('show');
        setupFullViewDrag();
      }
    }

    // è¨­å®šæ‹–æ›³åŠŸèƒ½
    function setupFullViewDrag() {
      const wrapper = document.getElementById('fullViewWrapper');
      
      wrapper.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('full-view-node')) return; // ä¸å½±éŸ¿ç¯€é»é»æ“Š
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        scrollStartX = wrapper.scrollLeft;
        scrollStartY = wrapper.scrollTop;
        wrapper.classList.add('dragging');
        e.preventDefault();
      });

      wrapper.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        wrapper.scrollLeft = scrollStartX - dx;
        wrapper.scrollTop = scrollStartY - dy;
      });

      wrapper.addEventListener('mouseup', () => {
        isDragging = false;
        wrapper.classList.remove('dragging');
      });

      wrapper.addEventListener('mouseleave', () => {
        isDragging = false;
        wrapper.classList.remove('dragging');
      });

      // æ»¾è¼ªç¸®æ”¾
      wrapper.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.05 : 0.05;
        zoomFullView(delta);
      }, { passive: false });

      // è§¸æ§æ”¯æ´
      let touchStartDist = 0;
      wrapper.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          touchStartDist = Math.sqrt(dx * dx + dy * dy);
        } else if (e.touches.length === 1) {
          dragStartX = e.touches[0].clientX;
          dragStartY = e.touches[0].clientY;
          scrollStartX = wrapper.scrollLeft;
          scrollStartY = wrapper.scrollTop;
          isDragging = true;
        }
      });

      wrapper.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const delta = (dist - touchStartDist) * 0.01;
          zoomFullView(delta);
          touchStartDist = dist;
          e.preventDefault();
        } else if (isDragging && e.touches.length === 1) {
          const dx = e.touches[0].clientX - dragStartX;
          const dy = e.touches[0].clientY - dragStartY;
          wrapper.scrollLeft = scrollStartX - dx;
          wrapper.scrollTop = scrollStartY - dy;
          e.preventDefault();
        }
      }, { passive: false });

      wrapper.addEventListener('touchend', () => {
        isDragging = false;
        touchStartDist = 0;
      });
    }

    // ç¸®æ”¾åŠŸèƒ½
    function zoomFullView(delta) {
      fullViewScale = Math.max(0.3, Math.min(2, fullViewScale + delta));
      const container = document.getElementById('fullViewContainer');
      container.style.transform = `scale(${fullViewScale})`;
      document.getElementById('zoomLevel').textContent = Math.round(fullViewScale * 100) + '%';
    }

    // é‡ç½®è¦–åœ–
    function resetFullView() {
      fullViewScale = 1;
      const container = document.getElementById('fullViewContainer');
      const wrapper = document.getElementById('fullViewWrapper');
      container.style.transform = 'scale(1)';
      wrapper.scrollLeft = 0;
      wrapper.scrollTop = 0;
      document.getElementById('zoomLevel').textContent = '100%';
    }

    function renderFullTopology() {
      const container = document.getElementById('fullViewContainer');
      container.innerHTML = '';

      const allNodes = Object.keys(knowledgeGraph);
      const visited = new Set();
      
      // æ‰¾å‡ºæ‰€æœ‰é ‚å±¤ç¯€é»ï¼ˆæ²’æœ‰ä¸Šæ¸¸çš„ï¼‰
      const topNodes = allNodes.filter(name => {
        const node = knowledgeGraph[name];
        return !node.upstream || node.upstream.length === 0;
      });

      // ç‚ºæ¯å€‹é ‚å±¤ç¯€é»å»ºç«‹ç¨ç«‹çš„æ‹“æ¨¸é«”ç³»
      const topologies = [];
      
      // BFS å»ºç«‹æ¯å€‹é«”ç³»çš„å±¤ç´šçµæ§‹
      function buildTopology(rootName) {
        const topology = {
          root: rootName,
          levels: {}
        };
        const localVisited = new Set();
        
        function assignLevel(nodeName, level) {
          if (localVisited.has(nodeName) || visited.has(nodeName)) return;
          localVisited.add(nodeName);
          visited.add(nodeName);
          
          if (!topology.levels[level]) topology.levels[level] = [];
          topology.levels[level].push(nodeName);
          
          const node = knowledgeGraph[nodeName];
          if (node.downstream) {
            node.downstream.forEach(downstreamName => {
              if (knowledgeGraph[downstreamName]) {
                assignLevel(downstreamName, level + 1);
              }
            });
          }
        }
        
        assignLevel(rootName, 0);
        return topology;
      }

      // ç‚ºæ¯å€‹é ‚å±¤ç¯€é»å»ºç«‹æ‹“æ¨¸
      topNodes.forEach(topNode => {
        const topology = buildTopology(topNode);
        topologies.push(topology);
      });

      // è™•ç†å­¤ç«‹ç¯€é»
      const unvisitedNodes = allNodes.filter(name => !visited.has(name));
      if (unvisitedNodes.length > 0) {
        console.log(`â„¹ï¸ ç™¼ç¾ ${unvisitedNodes.length} å€‹å­¤ç«‹ç¯€é»:`, unvisitedNodes);
        const orphanTopology = {
          root: '(å­¤ç«‹ç¯€é»)',
          levels: { 0: unvisitedNodes }
        };
        topologies.push(orphanTopology);
        unvisitedNodes.forEach(name => visited.add(name));
      }

      // è¨ˆç®—ä½ˆå±€åƒæ•¸
      const nodeSpacing = 180;
      const levelHeight = 150;
      const topologyGap = 300;  // é«”ç³»ä¹‹é–“çš„å‚ç›´é–“è·
      
      let currentY = 100;
      const nodePositions = {};

      // ç¹ªè£½æ¯å€‹æ‹“æ¨¸é«”ç³»
      topologies.forEach((topology, topologyIndex) => {
        // è¨ˆç®—æ­¤é«”ç³»çš„å¯¬åº¦ï¼ˆå–æœ€å¯¬çš„é‚£ä¸€å±¤ï¼‰
        const maxNodesInLevel = Math.max(...Object.values(topology.levels).map(nodes => nodes.length));
        const topologyWidth = Math.max(1000, maxNodesInLevel * nodeSpacing);
        
        // è¨ˆç®—æ­¤é«”ç³»çš„é«˜åº¦
        const levelCount = Object.keys(topology.levels).length;
        const topologyHeight = levelCount * levelHeight;
        
        // æ›´æ–°å®¹å™¨å°ºå¯¸
        const currentWidth = parseInt(container.style.minWidth) || 2000;
        container.style.minWidth = Math.max(currentWidth, topologyWidth + 200) + 'px';
        
        // ç¹ªè£½é«”ç³»æ¨™é¡Œï¼ˆå¦‚æœæœ‰å¤šå€‹é«”ç³»ï¼‰
        if (topologies.length > 1) {
          const titleEl = document.createElement('div');
          titleEl.style.position = 'absolute';
          titleEl.style.left = '50px';
          titleEl.style.top = (currentY - 30) + 'px';
          titleEl.style.color = '#ffc107';
          titleEl.style.fontSize = '1.2em';
          titleEl.style.fontWeight = '600';
          titleEl.textContent = `ğŸ“Š é«”ç³» ${topologyIndex + 1}: ${topology.root}`;
          container.appendChild(titleEl);
        }
        
        // ç¹ªè£½æ­¤é«”ç³»çš„æ¯ä¸€å±¤
        Object.keys(topology.levels).forEach(level => {
          const nodes = topology.levels[level];
          const levelWidth = nodes.length * nodeSpacing;
          const startX = (topologyWidth - levelWidth) / 2 + 100;
          const y = currentY + parseInt(level) * levelHeight;
          
          nodes.forEach((nodeName, i) => {
            const x = startX + i * nodeSpacing;
            nodePositions[nodeName] = { x, y };
            
            // ç¹ªè£½ç¯€é»
            const node = knowledgeGraph[nodeName];
            const nodeEl = document.createElement('div');
            nodeEl.className = `full-view-node ${node.source}`;
            nodeEl.textContent = nodeName;
            nodeEl.style.left = x + 'px';
            nodeEl.style.top = y + 'px';
            
            // é»æ“Šè·³è½‰
            nodeEl.addEventListener('click', () => {
              currentNode = nodeName;
              toggleFullView();
              renderTopology();
            });
            
            nodeEl.title = node.content;
            container.appendChild(nodeEl);
          });
        });
        
        // ç¹ªè£½æ­¤é«”ç³»çš„é€£æ¥ç·š
        Object.keys(topology.levels).forEach(level => {
          topology.levels[level].forEach(nodeName => {
            const node = knowledgeGraph[nodeName];
            const fromPos = nodePositions[nodeName];
            
            if (fromPos && node.downstream) {
              node.downstream.forEach(downstreamName => {
                const toPos = nodePositions[downstreamName];
                if (toPos) {
                  const line = document.createElement('div');
                  line.className = 'full-view-connection';
                  
                  const fromCenterX = fromPos.x + 50;
                  const fromCenterY = fromPos.y + 20;
                  const toCenterX = toPos.x + 50;
                  const toCenterY = toPos.y + 20;
                  
                  const dx = toCenterX - fromCenterX;
                  const dy = toCenterY - fromCenterY;
                  const length = Math.sqrt(dx * dx + dy * dy);
                  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                  
                  line.style.width = length + 'px';
                  line.style.left = fromCenterX + 'px';
                  line.style.top = fromCenterY + 'px';
                  line.style.transform = `rotate(${angle}deg)`;
                  
                  container.appendChild(line);
                }
              });
            }
          });
        });
        
        // ç§»å‹•åˆ°ä¸‹ä¸€å€‹é«”ç³»çš„èµ·å§‹ä½ç½®
        currentY += topologyHeight + topologyGap;
      });

      // æ›´æ–°å®¹å™¨é«˜åº¦
      container.style.minHeight = currentY + 'px';

      // é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
      console.log('ğŸ“Š å®Œæ•´æ‹“æ¨¸çµ±è¨ˆ:');
      console.log(`  ç¸½ç¯€é»æ•¸: ${allNodes.length}`);
      console.log(`  æ‹“æ¨¸é«”ç³»æ•¸: ${topologies.length}`);
      topologies.forEach((topology, i) => {
        const nodeCount = Object.values(topology.levels).flat().length;
        const levelCount = Object.keys(topology.levels).length;
        console.log(`  é«”ç³» ${i + 1} [${topology.root}]: ${nodeCount} å€‹ç¯€é»ï¼Œ${levelCount} å±¤`);
      });
    }
  </script>
</body>
</html>
