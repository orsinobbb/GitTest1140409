<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Áü•Ë≠òÂúñË≠ú‰∫íÂãïÁ≥ªÁµ± v3 - ÊãìÊ®∏Ë¶ñÂúñ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      text-align: center;
      color: white;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 10px;
    }
    .controls {
      max-width: 1200px;
      margin: 0 auto 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .controls input {
      flex: 1;
      min-width: 200px;
      padding: 12px 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 1em;
    }
    .controls button {
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9em;
    }
    .btn-search {
      background: white;
      color: #667eea;
    }
    .btn-view {
      background: #9c27b0;
      color: white;
    }
    .btn-export {
      background: #28a745;
      color: white;
    }
    .btn-import {
      background: #17a2b8;
      color: white;
    }
    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .graph-container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      min-height: 600px;
      position: relative;
    }
    .topology {
      width: 100%;
      height: 600px;
      position: relative;
    }
    .node {
      position: absolute;
      padding: 12px 20px;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      user-select: none;
      z-index: 10;
    }
    .node:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      z-index: 20;
    }
    .node.current {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 1.3em;
      padding: 18px 30px;
      z-index: 15;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .node.upstream {
      background: #ffc107;
      color: #000;
      border: 3px solid #ff9800;
    }
    .node.downstream {
      background: #e3f2fd;
      color: #1976d2;
      border: 2px solid #64b5f6;
    }
    .node.exists {
      background: #c8e6c9;
      border-color: #66bb6a;
    }
    .node.generating {
      background: #ffe0b2;
      border: 2px dashed #ff9800;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .connection {
      position: absolute;
      height: 2px;
      background: #ddd;
      transform-origin: left center;
      z-index: 0;
      pointer-events: none;
    }
    .connection.upstream {
      background: #ffc107;
      height: 3px;
      z-index: 0;
    }
    .tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      max-width: 400px;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      line-height: 1.6;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 193, 7, 0.3);
    }
    .tooltip.show {
      opacity: 1;
    }
    .tooltip-title {
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 1.1em;
      color: #ffc107;
    }
    .stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      font-size: 0.85em;
    }
    .stat-item {
      margin-bottom: 5px;
    }
    .stat-value {
      font-weight: 600;
      color: #667eea;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .loading-overlay.show {
      display: flex;
    }
    .loading-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    input[type="file"] {
      display: none;
    }
    
    /* ÂÆåÊï¥ÊãìÊ®∏Ë¶ñÂúñÊ®£Âºè */
    .full-view-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: none;
      overflow: hidden;
    }
    .full-view-overlay.show {
      display: block;
    }
    .full-view-wrapper {
      width: 100%;
      height: 100%;
      overflow: auto;
      cursor: grab;
      position: relative;
    }
    .full-view-wrapper.dragging {
      cursor: grabbing;
    }
    .full-view-container {
      min-width: 2000px;
      min-height: 1500px;
      position: relative;
      padding: 100px;
      transform-origin: 0 0;
    }
    .full-view-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(102, 126, 234, 0.95);
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 2001;
      backdrop-filter: blur(10px);
    }
    .full-view-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .zoom-btn {
      background: white;
      color: #667eea;
      border: none;
      padding: 8px 15px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1em;
    }
    .zoom-btn:hover {
      background: #f0f0f0;
    }
    .zoom-level {
      color: white;
      font-weight: 600;
      min-width: 60px;
      text-align: center;
    }
    .full-view-title {
      color: white;
      font-size: 1.3em;
      font-weight: 600;
    }
    .full-view-close {
      background: white;
      color: #667eea;
      border: none;
      padding: 10px 25px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1em;
    }
    .full-view-close:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
    }
    .full-view-node {
      position: absolute;
      padding: 10px 18px;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      font-size: 0.9em;
      z-index: 10;
    }
    .full-view-node:hover {
      transform: scale(1.15);
      z-index: 20;
    }
    .full-view-node.local {
      background: #c8e6c9;
      color: #1b5e20;
      border: 2px solid #66bb6a;
    }
    .full-view-node.ai {
      background: #e3f2fd;
      color: #0d47a1;
      border: 2px solid #64b5f6;
    }
    .full-view-connection {
      position: absolute;
      height: 1px;
      background: rgba(255, 255, 255, 0.3);
      transform-origin: left center;
      z-index: 0;
      pointer-events: none;
    }
    .full-view-legend {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 2001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.85em;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }
    .api-status {
      position: absolute;
      top: 20px;
      left: 20px;
      background: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.85em;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .api-status.ready {
      border-left: 4px solid #28a745;
    }
    .api-status.missing {
      border-left: 4px solid #dc3545;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üß† Áü•Ë≠òÂúñË≠ú‰∫íÂãïÁ≥ªÁµ±</h1>
    <div>v3.0 - ÊãìÊ®∏Ë¶ñË¶∫Âåñ | ÈªûÊìäÁØÄÈªûÂàáÊèõË¶ñÂúñ | ÊªëÈº†ÁßªÈÅéÈ°ØÁ§∫Ë™™Êòé</div>
  </div>

  <div class="controls">
    <input type="text" id="apiKey" placeholder="Google Gemini API Key (AIza...)">
    <input type="text" id="searchInput" placeholder="ÊêúÂ∞ãÁØÄÈªûÊàñËº∏ÂÖ•Êñ∞Ê¶ÇÂøµ...">
    <button class="btn-search" onclick="searchNode()">üîç ÊêúÂ∞ã</button>
    <button class="btn-view" onclick="toggleFullView()">üó∫Ô∏è ÂÆåÊï¥ÊãìÊ®∏</button>
    <button class="btn-export" onclick="exportGraph()">üíæ ÂåØÂá∫</button>
    <button class="btn-import" onclick="document.getElementById('importFile').click()">üìÇ ÂåØÂÖ•</button>
  </div>
  <input type="file" id="importFile" accept=".json" onchange="importGraph(event)">

  <div class="graph-container">
    <div class="api-status" id="apiStatus">
      <span id="apiStatusText">‚ö†Ô∏è Ë´ãË®≠ÂÆö API Key</span>
    </div>
    
    <div class="stats">
      <div class="stat-item">ÁØÄÈªûÁ∏ΩÊï∏: <span class="stat-value" id="totalNodes">6</span></div>
      <div class="stat-item">Êú¨Âú∞: <span class="stat-value" id="localNodes">6</span></div>
      <div class="stat-item">AIÁîüÊàê: <span class="stat-value" id="aiNodes">0</span></div>
    </div>

    <div class="topology" id="topology"></div>
    <div class="tooltip" id="tooltip">
      <div class="tooltip-title" id="tooltipTitle"></div>
      <div id="tooltipContent"></div>
    </div>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div>Ê≠£Âú®ÂëºÂè´ AI ÁîüÊàêÁØÄÈªû...</div>
    </div>
  </div>

  <!-- ÂÆåÊï¥ÊãìÊ®∏Ë¶ñÂúñ -->
  <div class="full-view-overlay" id="fullViewOverlay">
    <div class="full-view-header">
      <div class="full-view-title">üó∫Ô∏è ÂÆåÊï¥Áü•Ë≠òÂúñË≠úÊãìÊ®∏</div>
      <div class="full-view-controls">
        <button class="zoom-btn" onclick="zoomFullView(-0.1)">üîç‚àí</button>
        <div class="zoom-level" id="zoomLevel">100%</div>
        <button class="zoom-btn" onclick="zoomFullView(0.1)">üîç+</button>
        <button class="zoom-btn" onclick="resetFullView()">üîÑ ÈáçÁΩÆ</button>
        <button class="full-view-close" onclick="toggleFullView()">‚úï ÈóúÈñâ</button>
      </div>
    </div>
    <div class="full-view-wrapper" id="fullViewWrapper">
      <div class="full-view-container" id="fullViewContainer"></div>
    </div>
    <div class="full-view-legend">
      <div style="font-weight: 600; margin-bottom: 10px;">Âúñ‰æã</div>
      <div class="legend-item">
        <div class="legend-color" style="background: #c8e6c9; border: 2px solid #66bb6a;"></div>
        <span>Êú¨Âú∞ÁØÄÈªû</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #e3f2fd; border: 2px solid #64b5f6;"></div>
        <span>AI ÁîüÊàêÁØÄÈªû</span>
      </div>
      <div style="margin-top: 10px; font-size: 0.8em; color: #666;">
        üí° ÂèØÊãñÊõ≥ÁßªÂãï<br>
        üí° ÊªæËº™Á∏ÆÊîæ
      </div>
    </div>
  </div>

  <script>
    // ===== Áü•Ë≠òÂúñË≠úË≥áÊñô =====
    let knowledgeGraph = {
      "‰∫∫Â∑•Êô∫ÊÖß": {
        content: "‰∫∫Â∑•Êô∫ÊÖßÔºàAIÔºâÊòØËÆìÊ©üÂô®Â±ïÁèæÊô∫ÊÖßË°åÁÇ∫ÁöÑÊäÄË°ìÔºåÂåÖÊã¨Â≠∏Áøí„ÄÅÊé®ÁêÜ„ÄÅËá™Êàë‰øÆÊ≠£Á≠âËÉΩÂäõ„ÄÇÊ©üÂô®Â≠∏ÁøíÊòØÂØ¶Áèæ AI ÁöÑÈáçË¶ÅÊñπÊ≥ï‰πã‰∏Ä„ÄÇ",
        downstream: ["Ê©üÂô®Â≠∏Áøí", "Â∞àÂÆ∂Á≥ªÁµ±", "ÈõªËÖ¶Ë¶ñË¶∫"],
        upstream: [],
        source: "local"
      },
      "Ê©üÂô®Â≠∏Áøí": {
        content: "Ê©üÂô®Â≠∏ÁøíÊòØ‰∫∫Â∑•Êô∫ÊÖßÁöÑ‰∏ÄÂÄãÂàÜÊîØÔºåÈÄèÈÅéÊºîÁÆóÊ≥ïËÆìÈõªËÖ¶ÂæûË≥áÊñô‰∏≠Â≠∏ÁøíË¶èÂæãÔºåÁÑ°ÈúÄÊòéÁ¢∫Á∑®Á®ã„ÄÇÂ∏∏Ë¶ãÊáâÁî®ÂåÖÊã¨ÂΩ±ÂÉèËæ®Ë≠ò„ÄÅË™ûÈü≥Ëæ®Ë≠ò„ÄÅÊé®Ëñ¶Á≥ªÁµ±Á≠â„ÄÇ",
        downstream: ["Ê∑±Â∫¶Â≠∏Áøí", "Áõ£Áù£ÂºèÂ≠∏Áøí", "ÈùûÁõ£Áù£ÂºèÂ≠∏Áøí"],
        upstream: ["‰∫∫Â∑•Êô∫ÊÖß"],
        source: "local"
      },
      "Ê∑±Â∫¶Â≠∏Áøí": {
        content: "Ê∑±Â∫¶Â≠∏ÁøíÊòØÊ©üÂô®Â≠∏ÁøíÁöÑÂ≠êÈ†òÂüüÔºå‰ΩøÁî®Â§öÂ±§Á•ûÁ∂ìÁ∂≤Ë∑ØÊ®°Êì¨‰∫∫ËÖ¶ÈÅã‰Ωú„ÄÇÁâπÂà•ÊìÖÈï∑ËôïÁêÜÂΩ±ÂÉè„ÄÅË™ûÈü≥„ÄÅËá™ÁÑ∂Ë™ûË®ÄÁ≠âÈùûÁµêÊßãÂåñË≥áÊñô„ÄÇ",
        downstream: ["Á•ûÁ∂ìÁ∂≤Ë∑Ø", "Âç∑Á©çÁ•ûÁ∂ìÁ∂≤Ë∑Ø", "Âæ™Áí∞Á•ûÁ∂ìÁ∂≤Ë∑Ø"],
        upstream: ["Ê©üÂô®Â≠∏Áøí"],
        source: "local"
      },
      "Á•ûÁ∂ìÁ∂≤Ë∑Ø": {
        content: "Á•ûÁ∂ìÁ∂≤Ë∑ØÁî±Â§öÂÄã‰∫íÁõ∏ÈÄ£Êé•ÁöÑÁ•ûÁ∂ìÂÖÉÁµÑÊàêÔºåÈÄèÈÅéÊ¨äÈáçË™øÊï¥‰æÜÂ≠∏ÁøíË≥áÊñôÁâπÂæµ„ÄÇÊòØÊ∑±Â∫¶Â≠∏ÁøíÁöÑÂü∫Á§éÊû∂Êßã„ÄÇ",
        downstream: ["ÊÑüÁü•Âô®", "ÂïüÂãïÂáΩÊï∏", "ÂèçÂêëÂÇ≥Êí≠"],
        upstream: ["Ê∑±Â∫¶Â≠∏Áøí"],
        source: "local"
      },
      "Áõ£Áù£ÂºèÂ≠∏Áøí": {
        content: "Áõ£Áù£ÂºèÂ≠∏Áøí‰ΩøÁî®Ê®ôË®òÂ•ΩÁöÑË®ìÁ∑¥Ë≥áÊñôÔºåËÆìÊ®°ÂûãÂ≠∏ÁøíËº∏ÂÖ•ËàáËº∏Âá∫‰πãÈñìÁöÑÂ∞çÊáâÈóú‰øÇ„ÄÇÂ∏∏Ë¶ãÊºîÁÆóÊ≥ïÂåÖÊã¨Á∑öÊÄßËø¥Ê≠∏„ÄÅÊ±∫Á≠ñÊ®π„ÄÅÊîØÊè¥ÂêëÈáèÊ©üÁ≠â„ÄÇ",
        downstream: ["Á∑öÊÄßËø¥Ê≠∏", "Ê±∫Á≠ñÊ®π", "ÊîØÊè¥ÂêëÈáèÊ©ü"],
        upstream: ["Ê©üÂô®Â≠∏Áøí"],
        source: "local"
      },
      "ÈùûÁõ£Áù£ÂºèÂ≠∏Áøí": {
        content: "ÈùûÁõ£Áù£ÂºèÂ≠∏ÁøíËôïÁêÜÊú™Ê®ôË®òÁöÑË≥áÊñôÔºåÁõÆÊ®ôÊòØÁôºÁèæË≥áÊñô‰∏≠ÁöÑÈö±ËóèÁµêÊßãÊàñÊ®°Âºè„ÄÇÂ∏∏Ë¶ãÊñπÊ≥ïÂåÖÊã¨ËÅöÈ°ûÂàÜÊûê„ÄÅÈôçÁ∂≠Á≠â„ÄÇ",
        downstream: ["K-means", "‰∏ªÊàêÂàÜÂàÜÊûê"],
        upstream: ["Ê©üÂô®Â≠∏Áøí"],
        source: "local"
      }
    };

    let currentNode = "Ê©üÂô®Â≠∏Áøí";
    const apiKeyInput = document.getElementById('apiKey');
    const tooltip = document.getElementById('tooltip');

    // ===== Êõ¥Êñ∞Áµ±Ë®à =====
    function updateStats() {
      const total = Object.keys(knowledgeGraph).length;
      const local = Object.values(knowledgeGraph).filter(n => n.source === 'local').length;
      document.getElementById('totalNodes').textContent = total;
      document.getElementById('localNodes').textContent = local;
      document.getElementById('aiNodes').textContent = total - local;
      
      // Êõ¥Êñ∞ API ÁãÄÊÖã
      const apiStatus = document.getElementById('apiStatus');
      const apiStatusText = document.getElementById('apiStatusText');
      if (apiKeyInput.value.trim()) {
        apiStatus.className = 'api-status ready';
        apiStatusText.textContent = '‚úÖ API Â∑≤Ë®≠ÂÆö';
      } else {
        apiStatus.className = 'api-status missing';
        apiStatusText.textContent = '‚ö†Ô∏è Ë´ãË®≠ÂÆö API Key';
      }
    }

    // ===== ÂëºÂè´ LLM API =====
    async function callLLM(concept) {
      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        throw new Error('Ë´ãÂÖàË®≠ÂÆö API Key');
      }

      const prompt = `Ë´ãÁî®ÁπÅÈ´î‰∏≠Êñá‰ªãÁ¥π„Äå${concept}„ÄçÈÄôÂÄãÊ¶ÇÂøµÔºå‰∏¶Êèê‰æõÔºö
1. Á∞°Áü≠Ë™™ÊòéÔºà2-3Âè•Ë©±Ôºâ
2. 3ÂÄãÁõ∏ÈóúÁöÑ‰∏ãÊ∏∏Ê¶ÇÂøµÔºàÊõ¥ÂÖ∑È´îÁöÑÂ≠êÊ¶ÇÂøµÔºâ
3. 1ÂÄã‰∏äÊ∏∏Ê¶ÇÂøµÔºàÊõ¥ÊäΩË±°ÁöÑÁà∂Ê¶ÇÂøµÔºåÂ¶ÇÊûúÈÄôÂ∑≤Á∂ìÊòØÊúÄÈ†ÇÂ±§Ê¶ÇÂøµÂâáÁïôÁ©∫Èô£ÂàóÔºâ
4. ÊØèÂÄã‰∏ãÊ∏∏Ê¶ÇÂøµÁöÑÁ∞°Áü≠Ë™™ÊòéÔºà1-2Âè•Ë©±Ôºâ

Ë´ã‰ª• JSON Ê†ºÂºèÂõûÊáâÔºö
{
  "content": "Ë™™ÊòéÊñáÂ≠ó",
  "downstream": [
    {"name": "Ê¶ÇÂøµ1", "content": "Ê¶ÇÂøµ1ÁöÑË™™Êòé"},
    {"name": "Ê¶ÇÂøµ2", "content": "Ê¶ÇÂøµ2ÁöÑË™™Êòé"},
    {"name": "Ê¶ÇÂøµ3", "content": "Ê¶ÇÂøµ3ÁöÑË™™Êòé"}
  ],
  "upstream": ["Ê¶ÇÂøµA"]
}`;

      const model = "gemini-2.5-flash";
      const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: { temperature: 0.7, maxOutputTokens: 2048 }
        })
      });

      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error?.message || 'API ÂëºÂè´Â§±Êïó');
      }

      if (data.candidates && data.candidates.length > 0) {
        const text = data.candidates[0].content.parts[0].text;
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          return JSON.parse(jsonMatch[0]);
        }
      }
      throw new Error('ÁÑ°Ê≥ïËß£Êûê AI ÂõûÊáâ');
    }

    // ===== Áπ™Ë£ΩÈÄ£Êé•Á∑ö =====
    function drawConnection(fromX, fromY, toX, toY, isUpstream = false) {
      const dx = toX - fromX;
      const dy = toY - fromY;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;

      const line = document.createElement('div');
      line.className = isUpstream ? 'connection upstream' : 'connection';
      line.style.width = length + 'px';
      line.style.left = fromX + 'px';
      line.style.top = fromY + 'px';
      line.style.transform = `rotate(${angle}deg)`;
      
      return line;
    }

    // ===== Ê∏≤ÊüìÊãìÊ®∏Âúñ =====
    function renderTopology() {
      const topology = document.getElementById('topology');
      topology.innerHTML = '';

      const nodeData = knowledgeGraph[currentNode];
      if (!nodeData) {
        topology.innerHTML = '<div style="text-align: center; padding: 50px; color: #999;">ÁØÄÈªû‰∏çÂ≠òÂú®</div>';
        return;
      }

      const centerX = 600;
      const centerY = 300;

      // Áπ™Ë£ΩÁï∂ÂâçÁØÄÈªûÔºà‰∏≠ÂøÉÔºâ
      const currentEl = createNode(currentNode, centerX, centerY, 'current');
      topology.appendChild(currentEl);

      // Áπ™Ë£Ω‰∏äÊ∏∏ÁØÄÈªûÔºàÂ∑¶‰∏äÔºâ- ÂøÖÂÆöÂ∑≤Â≠òÂú®
      const upstream = nodeData.upstream || [];
      if (upstream.length > 0) {
        upstream.forEach((name, i) => {
          // Ê™¢Êü•‰∏äÊ∏∏ÁØÄÈªûÊòØÂê¶Â≠òÂú®
          if (!knowledgeGraph[name]) {
            console.warn(`‚ö†Ô∏è ‰∏äÊ∏∏ÁØÄÈªû„Äå${name}„Äç‰∏çÂ≠òÂú®ÊñºÂúñË≠ú‰∏≠ÔºåË´ãÊ™¢Êü•Ë≥áÊñôÂÆåÊï¥ÊÄß`);
            return; // Ë∑≥ÈÅé‰∏çÂ≠òÂú®ÁöÑ‰∏äÊ∏∏ÁØÄÈªû
          }
          
          const x = centerX - 280;
          const y = centerY - 100 + (i * 70);
          const node = createNode(name, x, y, 'upstream');
          topology.appendChild(node);
          
          // Áπ™Ë£ΩÈÄ£Êé•Á∑öÔºàÂæû‰∏äÊ∏∏ÊåáÂêëÁï∂ÂâçÁØÄÈªûÔºâ
          topology.appendChild(drawConnection(x + 80, y + 20, centerX - 30, centerY + 20, true));
        });
      }

      // Áπ™Ë£Ω‰∏ãÊ∏∏ÁØÄÈªûÔºàÁí∞ÁπûÔºâ
      const downstream = nodeData.downstream || [];
      if (downstream.length > 0) {
        const radius = 220;
        const angleStep = (2 * Math.PI) / downstream.length;
        const startAngle = -Math.PI / 2; // Âæû‰∏äÊñπÈñãÂßã

        downstream.forEach((name, i) => {
          const angle = startAngle + angleStep * i;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          
          // Âà§Êñ∑ÁØÄÈªûÊòØÂê¶Â∑≤Â≠òÂú®
          const className = knowledgeGraph[name] ? 'exists' : 'downstream';
          const node = createNode(name, x, y, className);
          topology.appendChild(node);
          
          // Áπ™Ë£ΩÈÄ£Êé•Á∑öÔºàÂæûÁï∂ÂâçÁØÄÈªûÊåáÂêë‰∏ãÊ∏∏Ôºâ
          topology.appendChild(drawConnection(centerX + 30, centerY + 20, x, y + 20));
        });
      }

      updateStats();
    }

    // ===== Âª∫Á´ãÁØÄÈªûÂÖÉÁ¥† =====
    function createNode(name, x, y, className) {
      const node = document.createElement('div');
      node.className = `node ${className}`;
      node.textContent = name;
      node.style.left = (x - 50) + 'px';
      node.style.top = (y - 20) + 'px';

      // ÈªûÊìä‰∫ã‰ª∂ - ÂÇ≥ÈÅû‰æÜÊ∫êÁØÄÈªûË≥áË®ä
      node.addEventListener('click', () => {
        // Â¶ÇÊûúÈªûÊìäÁöÑÊòØ‰∏ãÊ∏∏ÁØÄÈªûÔºåÂÇ≥ÈÅûÁï∂ÂâçÁØÄÈªû‰ΩúÁÇ∫‰æÜÊ∫ê
        const isDownstream = knowledgeGraph[currentNode]?.downstream?.includes(name);
        handleNodeClick(name, isDownstream ? currentNode : null);
      });

      // ÊªëÈº†ÁßªÂÖ•È°ØÁ§∫Ë™™Êòé
      node.addEventListener('mouseenter', (e) => {
        if (knowledgeGraph[name]) {
          const rect = node.getBoundingClientRect();
          
          tooltip.querySelector('#tooltipTitle').textContent = name;
          tooltip.querySelector('#tooltipContent').textContent = knowledgeGraph[name].content;
          
          // Ë®àÁÆó tooltip ‰ΩçÁΩÆÔºöÂÑ™ÂÖàÈ°ØÁ§∫Âú®ÁØÄÈªûÂè≥ÂÅ¥ÔºåÂ¶ÇÊûúË∂ÖÂá∫Ë¶ñÁ™óÂâáÈ°ØÁ§∫Âú®Â∑¶ÂÅ¥
          const tooltipWidth = 400; // tooltip ÁöÑÊúÄÂ§ßÂØ¨Â∫¶
          const showOnRight = (rect.right + tooltipWidth + 20) < window.innerWidth;
          
          if (showOnRight) {
            // È°ØÁ§∫Âú®Âè≥ÂÅ¥
            tooltip.style.left = (rect.right + 10) + 'px';
          } else {
            // È°ØÁ§∫Âú®Â∑¶ÂÅ¥
            tooltip.style.left = (rect.left - tooltipWidth - 10) + 'px';
          }
          
          // ÂûÇÁõ¥‰ΩçÁΩÆÔºöËàáÁØÄÈªûÈ†ÇÈÉ®Â∞çÈΩä
          tooltip.style.top = rect.top + 'px';
          tooltip.classList.add('show');
        }
      });

      node.addEventListener('mouseleave', () => {
        tooltip.classList.remove('show');
      });

      return node;
    }

    // ===== ËôïÁêÜÁØÄÈªûÈªûÊìä =====
    async function handleNodeClick(name, sourceNode = null) {
      // Ê™¢Êü•ÁØÄÈªûÊòØÂê¶Â≠òÂú®
      const nodeExists = knowledgeGraph[name];
      
      if (!nodeExists) {
        // ÁØÄÈªû‰∏çÂ≠òÂú®ÔºåÂëºÂè´ API ÁîüÊàê
        document.getElementById('loadingOverlay').classList.add('show');
        
        try {
          const data = await callLLM(name);
          
          // Âº∑Âà∂‰ΩøÁî®‰æÜÊ∫êÁØÄÈªû‰ΩúÁÇ∫‰∏äÊ∏∏
          const correctUpstream = sourceNode ? [sourceNode] : (data.upstream || []);
          
          // ËôïÁêÜ‰∏ãÊ∏∏Ë≥áÊñôÊ†ºÂºè
          let downstreamNames = [];
          if (data.downstream && data.downstream.length > 0) {
            if (typeof data.downstream[0] === 'string') {
              downstreamNames = data.downstream;
            } else if (typeof data.downstream[0] === 'object') {
              downstreamNames = data.downstream.map(d => d.name);
              
              // È†êÂÖàÁîüÊàê‰∏ãÊ∏∏ÁØÄÈªû
              data.downstream.forEach(downstreamNode => {
                if (!knowledgeGraph[downstreamNode.name]) {
                  knowledgeGraph[downstreamNode.name] = {
                    content: downstreamNode.content,
                    downstream: [],  // ÂÖàË®≠ÁÇ∫Á©∫ÔºåÈªûÊìäÊôÇÂÜçÁîüÊàê
                    upstream: [name],
                    source: 'ai'
                  };
                  console.log(`  ‚úÖ È†êÂÖàÁîüÊàê‰∏ãÊ∏∏ÁØÄÈªû: ${downstreamNode.name}`);
                }
              });
            }
          }
          
          // ÂÑ≤Â≠òÁï∂ÂâçÁØÄÈªû
          knowledgeGraph[name] = {
            content: data.content,
            downstream: downstreamNames,
            upstream: correctUpstream,
            source: 'ai'
          };
          
          console.log(`‚úÖ AI ÁîüÊàêÊñ∞ÁØÄÈªû: ${name}`);
          console.log(`üìç ‰∏äÊ∏∏Ë®≠ÂÆöÁÇ∫: ${correctUpstream.join(', ') || '(È†ÇÂ±§ÁØÄÈªû)'}`);
          console.log(`üì¶ ‰∏ãÊ∏∏ÁØÄÈªû: ${downstreamNames.join(', ')}`);
          
        } catch (error) {
          alert('‚ùå ÁîüÊàêÂ§±ÊïóÔºö' + error.message);
          document.getElementById('loadingOverlay').classList.remove('show');
          return;
        }
        
        document.getElementById('loadingOverlay').classList.remove('show');
      } else {
        // ÁØÄÈªûÂ∑≤Â≠òÂú®
        console.log(`‚úÖ ËÆÄÂèñÂ∑≤Â≠òÂú®ÁØÄÈªû: ${name}`);
        
        // üîß ÈóúÈçµ‰øÆÊ≠£ÔºöÊ™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÂ±ïÈñã‰∏ãÊ∏∏
        const node = knowledgeGraph[name];
        if (node.downstream && node.downstream.length === 0 && node.source === 'ai') {
          // ÈÄôÊòØ‰∏ÄÂÄã AI ÁîüÊàêÁöÑËëâÁØÄÈªûÔºåË©¢ÂïèÊòØÂê¶Ë¶ÅÂ±ïÈñã
          const shouldExpand = confirm(`„Äå${name}„ÄçÁõÆÂâçÊ≤íÊúâ‰∏ãÊ∏∏ÁØÄÈªûÔºåÊòØÂê¶‰ΩøÁî® AI ÁîüÊàê‰∏ãÊ∏∏Ê¶ÇÂøµÔºü`);
          if (shouldExpand) {
            document.getElementById('loadingOverlay').classList.add('show');
            
            try {
              const data = await callLLM(name);
              
              // Êõ¥Êñ∞‰∏ãÊ∏∏
              let downstreamNames = [];
              if (data.downstream && data.downstream.length > 0) {
                if (typeof data.downstream[0] === 'string') {
                  downstreamNames = data.downstream;
                } else if (typeof data.downstream[0] === 'object') {
                  downstreamNames = data.downstream.map(d => d.name);
                  
                  data.downstream.forEach(downstreamNode => {
                    if (!knowledgeGraph[downstreamNode.name]) {
                      knowledgeGraph[downstreamNode.name] = {
                        content: downstreamNode.content,
                        downstream: [],
                        upstream: [name],
                        source: 'ai'
                      };
                      console.log(`  ‚úÖ È†êÂÖàÁîüÊàê‰∏ãÊ∏∏ÁØÄÈªû: ${downstreamNode.name}`);
                    }
                  });
                }
              }
              
              // Êõ¥Êñ∞Áï∂ÂâçÁØÄÈªûÁöÑ‰∏ãÊ∏∏
              knowledgeGraph[name].downstream = downstreamNames;
              console.log(`‚úÖ Â±ïÈñãÁØÄÈªû: ${name}`);
              console.log(`üì¶ Êñ∞Â¢û‰∏ãÊ∏∏: ${downstreamNames.join(', ')}`);
              
            } catch (error) {
              alert('‚ùå Â±ïÈñãÂ§±ÊïóÔºö' + error.message);
            }
            
            document.getElementById('loadingOverlay').classList.remove('show');
          }
        }
      }

      // ÂàáÊèõÂà∞Êñ∞ÁØÄÈªû
      currentNode = name;
      renderTopology();
      updateStats();
    }

    // ===== ÊêúÂ∞ãÁØÄÈªû =====
    function searchNode() {
      const query = document.getElementById('searchInput').value.trim();
      if (!query) return;

      if (knowledgeGraph[query]) {
        currentNode = query;
        renderTopology();
      } else {
        if (confirm(`„Äå${query}„Äç‰∏çÂ≠òÂú®ÔºåÊòØÂê¶‰ΩøÁî® AI ÁîüÊàêÔºü`)) {
          handleNodeClick(query, null);  // Ê≤íÊúâ‰æÜÊ∫êÁØÄÈªû
        }
      }
    }

    // ===== ÂåØÂá∫ÂúñË≠ú =====
    function exportGraph() {
      const dataStr = JSON.stringify(knowledgeGraph, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `knowledge_graph_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ===== ÂåØÂÖ•ÂúñË≠ú =====
    function importGraph(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          knowledgeGraph = JSON.parse(e.target.result);
          renderTopology();
          alert('‚úÖ ÂúñË≠úÂ∑≤ÂåØÂÖ•');
        } catch {
          alert('‚ùå ÂåØÂÖ•Â§±Êïó');
        }
      };
      reader.readAsText(file);
    }

    // Áõ£ËÅΩ API Key ËÆäÂåñ
    apiKeyInput.addEventListener('input', updateStats);

    // ===== Ë≥áÊñôÂÆåÊï¥ÊÄßÊ™¢Êü•ËàáËá™Âãï‰øÆÊ≠£ =====
    function validateAndFixGraph() {
      const issues = [];
      const fixes = [];
      
      Object.keys(knowledgeGraph).forEach(nodeName => {
        const node = knowledgeGraph[nodeName];
        
        // Ê™¢Êü•‰∏¶‰øÆÊ≠£‰∏äÊ∏∏ÁØÄÈªû
        if (node.upstream && node.upstream.length > 0) {
          const validUpstream = [];
          
          node.upstream.forEach(upstreamName => {
            if (!knowledgeGraph[upstreamName]) {
              issues.push(`‚ùå ÁØÄÈªû„Äå${nodeName}„ÄçÁöÑ‰∏äÊ∏∏„Äå${upstreamName}„Äç‰∏çÂ≠òÂú®`);
              
              // ÂòóË©¶Ëá™Âãï‰øÆÊ≠£ÔºöÂæûÊâÄÊúâÁØÄÈªû‰∏≠ÊâæÂá∫ÂåÖÂê´Ê≠§ÁØÄÈªû‰ΩúÁÇ∫‰∏ãÊ∏∏ÁöÑÁØÄÈªû
              let found = false;
              Object.keys(knowledgeGraph).forEach(candidateName => {
                const candidate = knowledgeGraph[candidateName];
                if (candidate.downstream && candidate.downstream.includes(nodeName)) {
                  validUpstream.push(candidateName);
                  fixes.push(`‚úÖ Ëá™Âãï‰øÆÊ≠£Ôºö„Äå${nodeName}„ÄçÁöÑ‰∏äÊ∏∏ÊîπÁÇ∫„Äå${candidateName}„Äç`);
                  found = true;
                }
              });
              
              if (!found) {
                console.warn(`‚ö†Ô∏è ÁÑ°Ê≥ïËá™Âãï‰øÆÊ≠£„Äå${nodeName}„ÄçÁöÑ‰∏äÊ∏∏ÔºåÂ∑≤ÁßªÈô§„Äå${upstreamName}„Äç`);
              }
            } else {
              validUpstream.push(upstreamName);
            }
          });
          
          // Êõ¥Êñ∞ÁÇ∫ÊúâÊïàÁöÑ‰∏äÊ∏∏ÂàóË°®
          node.upstream = validUpstream;
        }
      });
      
      if (fixes.length > 0) {
        console.log('üîß Ëá™Âãï‰øÆÊ≠£ÂÆåÊàêÔºö');
        fixes.forEach(fix => console.log(fix));
      }
      
      if (issues.length > 0) {
        console.warn('‚ö†Ô∏è Ë≥áÊñôÂÆåÊï¥ÊÄßÂïèÈ°åÔºàÂ∑≤‰øÆÊ≠£ÔºâÔºö');
        issues.forEach(issue => console.warn(issue));
        return false;
      } else {
        console.log('‚úÖ Ë≥áÊñôÂÆåÊï¥ÊÄßÊ™¢Êü•ÈÄöÈÅé');
        return true;
      }
    }

    // ÂàùÂßãÂåñ
    validateAndFixGraph();
    renderTopology();

    // ===== ÂÆåÊï¥ÊãìÊ®∏Ë¶ñÂúñ =====
    let fullViewScale = 1;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let scrollStartX = 0;
    let scrollStartY = 0;

    function toggleFullView() {
      const overlay = document.getElementById('fullViewOverlay');
      const isShowing = overlay.classList.contains('show');
      
      if (isShowing) {
        overlay.classList.remove('show');
      } else {
        renderFullTopology();
        overlay.classList.add('show');
        setupFullViewDrag();
      }
    }

    // Ë®≠ÂÆöÊãñÊõ≥ÂäüËÉΩ
    function setupFullViewDrag() {
      const wrapper = document.getElementById('fullViewWrapper');
      
      wrapper.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('full-view-node')) return; // ‰∏çÂΩ±ÈüøÁØÄÈªûÈªûÊìä
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        scrollStartX = wrapper.scrollLeft;
        scrollStartY = wrapper.scrollTop;
        wrapper.classList.add('dragging');
        e.preventDefault();
      });

      wrapper.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        wrapper.scrollLeft = scrollStartX - dx;
        wrapper.scrollTop = scrollStartY - dy;
      });

      wrapper.addEventListener('mouseup', () => {
        isDragging = false;
        wrapper.classList.remove('dragging');
      });

      wrapper.addEventListener('mouseleave', () => {
        isDragging = false;
        wrapper.classList.remove('dragging');
      });

      // ÊªæËº™Á∏ÆÊîæ
      wrapper.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.05 : 0.05;
        zoomFullView(delta);
      }, { passive: false });

      // Ëß∏ÊéßÊîØÊè¥
      let touchStartDist = 0;
      wrapper.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          touchStartDist = Math.sqrt(dx * dx + dy * dy);
        } else if (e.touches.length === 1) {
          dragStartX = e.touches[0].clientX;
          dragStartY = e.touches[0].clientY;
          scrollStartX = wrapper.scrollLeft;
          scrollStartY = wrapper.scrollTop;
          isDragging = true;
        }
      });

      wrapper.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const delta = (dist - touchStartDist) * 0.01;
          zoomFullView(delta);
          touchStartDist = dist;
          e.preventDefault();
        } else if (isDragging && e.touches.length === 1) {
          const dx = e.touches[0].clientX - dragStartX;
          const dy = e.touches[0].clientY - dragStartY;
          wrapper.scrollLeft = scrollStartX - dx;
          wrapper.scrollTop = scrollStartY - dy;
          e.preventDefault();
        }
      }, { passive: false });

      wrapper.addEventListener('touchend', () => {
        isDragging = false;
        touchStartDist = 0;
      });
    }

    // Á∏ÆÊîæÂäüËÉΩ
    function zoomFullView(delta) {
      fullViewScale = Math.max(0.3, Math.min(2, fullViewScale + delta));
      const container = document.getElementById('fullViewContainer');
      container.style.transform = `scale(${fullViewScale})`;
      document.getElementById('zoomLevel').textContent = Math.round(fullViewScale * 100) + '%';
    }

    // ÈáçÁΩÆË¶ñÂúñ
    function resetFullView() {
      fullViewScale = 1;
      const container = document.getElementById('fullViewContainer');
      const wrapper = document.getElementById('fullViewWrapper');
      container.style.transform = 'scale(1)';
      wrapper.scrollLeft = 0;
      wrapper.scrollTop = 0;
      document.getElementById('zoomLevel').textContent = '100%';
    }

    function renderFullTopology() {
      const container = document.getElementById('fullViewContainer');
      container.innerHTML = '';

      const allNodes = Object.keys(knowledgeGraph);
      const visited = new Set();
      
      // ÊâæÂá∫ÊâÄÊúâÈ†ÇÂ±§ÁØÄÈªûÔºàÊ≤íÊúâ‰∏äÊ∏∏ÁöÑÔºâ
      const topNodes = allNodes.filter(name => {
        const node = knowledgeGraph[name];
        return !node.upstream || node.upstream.length === 0;
      });

      // ÁÇ∫ÊØèÂÄãÈ†ÇÂ±§ÁØÄÈªûÂª∫Á´ãÁç®Á´ãÁöÑÊãìÊ®∏È´îÁ≥ª
      const topologies = [];
      
      // BFS Âª∫Á´ãÊØèÂÄãÈ´îÁ≥ªÁöÑÂ±§Á¥öÁµêÊßã
      function buildTopology(rootName) {
        const topology = {
          root: rootName,
          levels: {}
        };
        const localVisited = new Set();
        
        function assignLevel(nodeName, level) {
          if (localVisited.has(nodeName) || visited.has(nodeName)) return;
          localVisited.add(nodeName);
          visited.add(nodeName);
          
          if (!topology.levels[level]) topology.levels[level] = [];
          topology.levels[level].push(nodeName);
          
          const node = knowledgeGraph[nodeName];
          if (node.downstream) {
            node.downstream.forEach(downstreamName => {
              if (knowledgeGraph[downstreamName]) {
                assignLevel(downstreamName, level + 1);
              }
            });
          }
        }
        
        assignLevel(rootName, 0);
        return topology;
      }

      // ÁÇ∫ÊØèÂÄãÈ†ÇÂ±§ÁØÄÈªûÂª∫Á´ãÊãìÊ®∏
      topNodes.forEach(topNode => {
        const topology = buildTopology(topNode);
        topologies.push(topology);
      });

      // ËôïÁêÜÂ≠§Á´ãÁØÄÈªû
      const unvisitedNodes = allNodes.filter(name => !visited.has(name));
      if (unvisitedNodes.length > 0) {
        console.log(`‚ÑπÔ∏è ÁôºÁèæ ${unvisitedNodes.length} ÂÄãÂ≠§Á´ãÁØÄÈªû:`, unvisitedNodes);
        const orphanTopology = {
          root: '(Â≠§Á´ãÁØÄÈªû)',
          levels: { 0: unvisitedNodes }
        };
        topologies.push(orphanTopology);
        unvisitedNodes.forEach(name => visited.add(name));
      }

      // Ë®àÁÆó‰ΩàÂ±ÄÂèÉÊï∏
      const nodeSpacing = 180;
      const levelHeight = 150;
      const topologyGap = 300;  // È´îÁ≥ª‰πãÈñìÁöÑÂûÇÁõ¥ÈñìË∑ù
      
      let currentY = 100;
      const nodePositions = {};

      // Áπ™Ë£ΩÊØèÂÄãÊãìÊ®∏È´îÁ≥ª
      topologies.forEach((topology, topologyIndex) => {
        // Ë®àÁÆóÊ≠§È´îÁ≥ªÁöÑÂØ¨Â∫¶ÔºàÂèñÊúÄÂØ¨ÁöÑÈÇ£‰∏ÄÂ±§Ôºâ
        const maxNodesInLevel = Math.max(...Object.values(topology.levels).map(nodes => nodes.length));
        const topologyWidth = Math.max(1000, maxNodesInLevel * nodeSpacing);
        
        // Ë®àÁÆóÊ≠§È´îÁ≥ªÁöÑÈ´òÂ∫¶
        const levelCount = Object.keys(topology.levels).length;
        const topologyHeight = levelCount * levelHeight;
        
        // Êõ¥Êñ∞ÂÆπÂô®Â∞∫ÂØ∏
        const currentWidth = parseInt(container.style.minWidth) || 2000;
        container.style.minWidth = Math.max(currentWidth, topologyWidth + 200) + 'px';
        
        // Áπ™Ë£ΩÈ´îÁ≥ªÊ®ôÈ°åÔºàÂ¶ÇÊûúÊúâÂ§öÂÄãÈ´îÁ≥ªÔºâ
        if (topologies.length > 1) {
          const titleEl = document.createElement('div');
          titleEl.style.position = 'absolute';
          titleEl.style.left = '50px';
          titleEl.style.top = (currentY - 30) + 'px';
          titleEl.style.color = '#ffc107';
          titleEl.style.fontSize = '1.2em';
          titleEl.style.fontWeight = '600';
          titleEl.textContent = `üìä È´îÁ≥ª ${topologyIndex + 1}: ${topology.root}`;
          container.appendChild(titleEl);
        }
        
        // Áπ™Ë£ΩÊ≠§È´îÁ≥ªÁöÑÊØè‰∏ÄÂ±§
        Object.keys(topology.levels).forEach(level => {
          const nodes = topology.levels[level];
          const levelWidth = nodes.length * nodeSpacing;
          const startX = (topologyWidth - levelWidth) / 2 + 100;
          const y = currentY + parseInt(level) * levelHeight;
          
          nodes.forEach((nodeName, i) => {
            const x = startX + i * nodeSpacing;
            nodePositions[nodeName] = { x, y };
            
            // Áπ™Ë£ΩÁØÄÈªû
            const node = knowledgeGraph[nodeName];
            const nodeEl = document.createElement('div');
            nodeEl.className = `full-view-node ${node.source}`;
            nodeEl.textContent = nodeName;
            nodeEl.style.left = x + 'px';
            nodeEl.style.top = y + 'px';
            
            // ÈªûÊìäË∑≥ËΩâ
            nodeEl.addEventListener('click', () => {
              currentNode = nodeName;
              toggleFullView();
              renderTopology();
            });
            
            nodeEl.title = node.content;
            container.appendChild(nodeEl);
          });
        });
        
        // Áπ™Ë£ΩÊ≠§È´îÁ≥ªÁöÑÈÄ£Êé•Á∑ö
        Object.keys(topology.levels).forEach(level => {
          topology.levels[level].forEach(nodeName => {
            const node = knowledgeGraph[nodeName];
            const fromPos = nodePositions[nodeName];
            
            if (fromPos && node.downstream) {
              node.downstream.forEach(downstreamName => {
                const toPos = nodePositions[downstreamName];
                if (toPos) {
                  const line = document.createElement('div');
                  line.className = 'full-view-connection';
                  
                  const fromCenterX = fromPos.x + 50;
                  const fromCenterY = fromPos.y + 20;
                  const toCenterX = toPos.x + 50;
                  const toCenterY = toPos.y + 20;
                  
                  const dx = toCenterX - fromCenterX;
                  const dy = toCenterY - fromCenterY;
                  const length = Math.sqrt(dx * dx + dy * dy);
                  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                  
                  line.style.width = length + 'px';
                  line.style.left = fromCenterX + 'px';
                  line.style.top = fromCenterY + 'px';
                  line.style.transform = `rotate(${angle}deg)`;
                  
                  container.appendChild(line);
                }
              });
            }
          });
        });
        
        // ÁßªÂãïÂà∞‰∏ã‰∏ÄÂÄãÈ´îÁ≥ªÁöÑËµ∑Âßã‰ΩçÁΩÆ
        currentY += topologyHeight + topologyGap;
      });

      // Êõ¥Êñ∞ÂÆπÂô®È´òÂ∫¶
      container.style.minHeight = currentY + 'px';

      // È°ØÁ§∫Áµ±Ë®àË≥áË®ä
      console.log('üìä ÂÆåÊï¥ÊãìÊ®∏Áµ±Ë®à:');
      console.log(`  Á∏ΩÁØÄÈªûÊï∏: ${allNodes.length}`);
      console.log(`  ÊãìÊ®∏È´îÁ≥ªÊï∏: ${topologies.length}`);
      topologies.forEach((topology, i) => {
        const nodeCount = Object.values(topology.levels).flat().length;
        const levelCount = Object.keys(topology.levels).length;
        console.log(`  È´îÁ≥ª ${i + 1} [${topology.root}]: ${nodeCount} ÂÄãÁØÄÈªûÔºå${levelCount} Â±§`);
      });
    }
  </script>
</body>
</html>
