<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>åœ–ç‰‡è‡ªå‹•åˆä½µå·¥å…·ï¼ˆé€è¡Œåƒç´ æ¯”å°ï¼‰</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    canvas {
      border: 1px solid #aaa;
      background: #fff;
      margin-top: 20px;
      display: block;
    }
    #status {
      margin-top: 10px;
      color: #336699;
    }
    #merge-log {
      margin-top: 20px;
      padding: 10px;
      border: 1px dashed #888;
      background: #fff;
      font-size: 14px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h2>ğŸ“· åœ–ç‰‡è‡ªå‹•åˆä½µå·¥å…·ï¼ˆä½¿ç”¨é€è¡Œåƒç´ æ¯”å°ï¼‰</h2>

  <input type="file" id="imageInput" multiple accept="image/*"><br><br>
  <button id="mergeBtn">â–¶ï¸ é–‹å§‹åˆä½µ</button>
  <p id="status">ğŸ”” è«‹å…ˆé¸æ“‡åœ–ç‰‡...</p>

  <canvas id="canvas" width="800" height="1000"></canvas>
  <div id="merge-log">ğŸ“‹ åˆä½µç´€éŒ„å°šæœªå»ºç«‹</div>

  <script>
    const input = document.getElementById('imageInput');
    const mergeBtn = document.getElementById('mergeBtn');
    const status = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const mergeLogBox = document.getElementById('merge-log');

    let loadedImages = [];

    input.addEventListener('change', async function () {
      const files = [...this.files];
      if (files.length === 0) {
        status.textContent = 'âš ï¸ æ²’æœ‰é¸æ“‡åœ–ç‰‡';
        return;
      }

      status.textContent = 'ğŸ“¥ åœ–ç‰‡è¼‰å…¥ä¸­...';
      try {
        loadedImages = await Promise.all(files.map(loadImage));
        status.textContent = `âœ… å·²æˆåŠŸè¼‰å…¥ ${loadedImages.length} å¼µåœ–ç‰‡ï¼Œè«‹é»ã€Œé–‹å§‹åˆä½µã€`;
        mergeLogBox.textContent = "ğŸ“‹ åˆä½µç´€éŒ„å°šæœªå»ºç«‹";
      } catch (e) {
        status.textContent = 'âŒ åœ–ç‰‡è¼‰å…¥å¤±æ•—';
        console.error(e);
      }
    });

    mergeBtn.addEventListener('click', async function () {
      if (loadedImages.length === 0) {
        status.textContent = 'âš ï¸ å°šæœªè¼‰å…¥åœ–ç‰‡';
        return;
      }

      status.textContent = `ğŸ› ï¸ æ­£åœ¨åˆä½µåœ–ç‰‡ä¸­...`;
      await mergeImages(loadedImages);
      status.textContent = 'ğŸ‰ åˆä½µå®Œæˆï¼å¯ä»¥å³éµå¦å­˜åœ–ç‰‡';
    });

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    async function mergeImages(images) {
      const width = images[0].width;
      canvas.width = width;
      canvas.height = images.reduce((sum, img) => sum + img.height, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let currentY = 0;
      const mergeLog = [];

      ctx.drawImage(images[0], 0, currentY);
      currentY += images[0].height;

      for (let i = 1; i < images.length; i++) {
        const overlap = await detectOverlap(images[i - 1], images[i]);
        mergeLog.push(`ğŸ”— åœ–ç‰‡ ${i} â åœ–ç‰‡ ${i + 1}ï¼Œé‡ç–Šé«˜åº¦ï¼š${overlap}px`);
        currentY -= overlap;
        ctx.drawImage(images[i], 0, currentY);
        currentY += images[i].height;
      }

      canvas.height = currentY;
      mergeLogBox.textContent = `ğŸ“‹ åˆä½µç´€éŒ„ï¼š\n${mergeLog.join("\n")}`;
      console.log("ğŸ§¾ åˆä½µç´€éŒ„ï¼š\n" + mergeLog.join("\n"));
    }

    async function detectOverlap(imgA, imgB) {
      const width = imgA.width;
      const maxOverlap = Math.min(imgA.height, imgB.height, 200);
      const thresholdPerPixel = 15;       // æ¯å€‹åƒç´ å…è¨±èª¤å·®å€¼
      const rowTolerance = 0.05;          // å–®ä¸€ row æœ€å¤š 5% ä¸åŒåƒç´ 
      const minSimilarRows = 5;           // è‡³å°‘å¹¾è¡Œç›¸ä¼¼æ‰è¦–ç‚ºé‡ç–Š

      const tempCanvasA = document.createElement('canvas');
      const tempCanvasB = document.createElement('canvas');
      const ctxA = tempCanvasA.getContext('2d');
      const ctxB = tempCanvasB.getContext('2d');
      tempCanvasA.width = width;
      tempCanvasB.width = width;

      for (let overlap = maxOverlap; overlap > 10; overlap--) {
        tempCanvasA.height = overlap;
        tempCanvasB.height = overlap;

        ctxA.clearRect(0, 0, width, overlap);
        ctxB.clearRect(0, 0, width, overlap);
        ctxA.drawImage(imgA, 0, imgA.height - overlap, width, overlap, 0, 0, width, overlap);
        ctxB.drawImage(imgB, 0, 0, width, overlap, 0, 0, width, overlap);

        const dataA = ctxA.getImageData(0, 0, width, overlap).data;
        const dataB = ctxB.getImageData(0, 0, width, overlap).data;

        let similarRowCount = 0;

        for (let row = 0; row < overlap; row++) {
          let rowDiff = 0;
          for (let col = 0; col < width * 4; col++) {
            const idx = row * width * 4 + col;
            if (Math.abs(dataA[idx] - dataB[idx]) > thresholdPerPixel) {
              rowDiff++;
            }
          }
          const rowRatio = rowDiff / (width * 4);
          if (rowRatio < rowTolerance) similarRowCount++;
        }

        if (similarRowCount >= minSimilarRows) {
          return overlap;
        }
      }

      return 0;
    }
  </script>
</body>
</html>